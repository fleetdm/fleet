package kolide

import (
	"context"
	"time"
	"fmt"
	"encoding/json"
)

type CarveStore interface {
	NewCarve(metadata *CarveMetadata) (*CarveMetadata, error)
	Carve(carveId int64) (*CarveMetadata, error)
	SaveCarve(metadata *CarveMetadata) error
	CarveBySessionId(sessionId string) (*CarveMetadata, error)
	CarveByName(name string) (*CarveMetadata, error)
	ListCarves(opt ListOptions) ([]*CarveMetadata, error)
	NewBlock(carveId, blockId int64, data []byte) error
	GetBlock(carveId, blockId int64) ([]byte, error)
}

type CarveService interface {
	CarveBegin(ctx context.Context, payload CarveBeginPayload) (*CarveMetadata, error)
	CarveBlock(ctx context.Context, payload CarveBlockPayload) error
	GetCarve(ctx context.Context, id int64) (*CarveMetadata, error)
	ListCarves(ctx context.Context, opt ListOptions) ([]*CarveMetadata, error)
	GetBlock(ctx context.Context, carveId, blockId int64) ([]byte, error)
}

type CarveStatus int

const (
	CarveStatusUnknown CarveStatus = iota
	CarveStatusInProgress
	CarveStatusCompleted
	CarveStatusFailed
	CarveStatusExpired
)

func (c CarveStatus) String() string {
	switch c {
	case CarveStatusInProgress:
		return "in_progress"
	case CarveStatusCompleted:
		return "completed"
	case CarveStatusFailed:
		return "failed"
	case CarveStatusExpired:
		return "expired"
	default:
		return "unknown"
	}
}

func (c CarveStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf(`"%s"`, c.String())), nil
}

func (c *CarveStatus) UnmarshalJSON(b []byte) error {
	var s string
	if err := json.Unmarshal(b, &s); err != nil {
		return err
	}

	switch s {
	case "in_progress":
		*c = CarveStatusInProgress
	case "completed":
		*c = CarveStatusCompleted
	case "failed":
		*c = CarveStatusFailed
	case "expired":
		*c = CarveStatusExpired
	case "unknown":
		*c = CarveStatusUnknown
	default:
		return fmt.Errorf("unknown carve status %s", s)
	}

	return nil
}

type CarveMetadata struct {
	// ID is the DB auto-increment ID for the carve.
	ID int64 `json:"id" db:"id"`
	// CreatedAt is the creation timestamp.
	CreatedAt time.Time `json:"created_at" db:"created_at"`
	// HostId is the ID of the host that initiated the carve.
	HostId uint `json:"host_id" db:"host_id"`
	// Name is the human readable name for this carve.
	Name string `json:"name" db:"name"`
	// BlockCount is the number of blocks in the carve.
	BlockCount int64 `json:"block_count" db:"block_count"`
	// BlcokSize is the size of each block in the carve.
	BlockSize int64 `json:"block_size" db:"block_size"`
	// CarveSize is the total size of the carve.
	CarveSize int64 `json:"carve_size" db:"carve_size"`
	// CarveId is a uuid generated by osquery for the carve.
	CarveId string `json:"carve_id" db:"carve_id"`
	// RequestId is the name of the query that kicked off this carve.
	RequestId string `json:"request_id" db:"request_id"`
	// SessionId is generated by Fleet and used by osquery to identify blocks.
	SessionId string `json:"session_id" db:"session_id"`
	// Status is the completion status of the carve.
	Status CarveStatus `json:"status" db:"status"`

	// MaxBlock is the highest block number currently stored for this carve.
	// This value is not stored directly, but generated from the carve_blocks
	// table.
	MaxBlock int64 `json:"max_block" db:"max_block"`
}

func (m *CarveMetadata) BlocksComplete() bool {
	return m.MaxBlock == m.BlockCount-1
}

type CarveBeginPayload struct {
	BlockCount int64
	BlockSize  int64
	CarveSize  int64
	CarveId    string
	RequestId  string
}

type CarveBlockPayload struct {
	SessionId string
	RequestId string
	BlockId   int64
	Data      []byte
}
