//go:build ignore
// +build ignore

// This program generates a mapping from AWS zone ID prefixes to region names
// by parsing the AWS documentation page.
//
// To run: go run gen_region_map.go

package main

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

const outputTemplate = `// Code generated by gen_aws_region_map.go; DO NOT EDIT.

package redis

// awsRegionMap maps AWS zone ID prefixes (e.g., "use2") to region names (e.g., "us-east-2")
var awsRegionMap = map[string]string{
{{- range $prefix, $region := . }}
	"{{ $prefix }}": "{{ $region }}",
{{- end }}
}
`

func parseZoneIDMappings(html string) map[string]string {
	regionMap := make(map[string]string)

	// Look for table rows containing zone IDs and regions
	// Pattern: <code>use1-az1</code> ... <code>us-east-1</code>
	rowRegex := regexp.MustCompile(`(?s)<tr[^>]*>(.*?)</tr>`)
	rows := rowRegex.FindAllStringSubmatch(html, -1)

	for _, rowMatch := range rows {
		row := rowMatch[1]

		// Look for code blocks containing zone IDs and region names
		codeRegex := regexp.MustCompile(`<code[^>]*>([^<]+)</code>`)
		codes := codeRegex.FindAllStringSubmatch(row, -1)

		var zoneID, regionName string
		for _, code := range codes {
			value := code[1]
			// Check if it's a zone ID (e.g., "use1-az1")
			if matched, _ := regexp.MatchString(`^[a-z]+[0-9]+-az[0-9]+$`, value); matched {
				zoneID = value
			}
			// Check if it's a region name (e.g., "us-east-1")
			if matched, _ := regexp.MatchString(`^[a-z]+-[a-z]+-[0-9]+$`, value); matched {
				regionName = value
			}
		}

		// If we found both in the same row
		if zoneID != "" && regionName != "" {
			// Extract prefix from zone ID
			parts := strings.Split(zoneID, "-")
			if len(parts) >= 2 && strings.HasPrefix(parts[1], "az") {
				prefix := parts[0]

				// Only add if we haven't seen this prefix before, or if it matches
				if existing, ok := regionMap[prefix]; !ok || existing == regionName {
					regionMap[prefix] = regionName
				}
			}
		}
	}

	return regionMap
}

func main() {
	// Fetch the AWS documentation page
	url := "https://docs.aws.amazon.com/global-infrastructure/latest/regions/aws-availability-zones.html"
	fmt.Fprintf(os.Stderr, "Fetching AWS documentation from %s\n", url)

	resp, err := http.Get(url)
	if err != nil {
		log.Fatalf("Failed to fetch AWS documentation: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Fatalf("Failed to fetch AWS documentation: HTTP %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Failed to read response body: %v", err)
	}

	// Parse the HTML to extract zone ID mappings
	regionMap := parseZoneIDMappings(string(body))

	if len(regionMap) == 0 {
		log.Fatal("No region mappings found in the documentation")
	}

	fmt.Fprintf(os.Stderr, "Found %d region mappings\n", len(regionMap))

	// Sort prefixes for consistent output
	var sortedPrefixes []string
	for prefix := range regionMap {
		sortedPrefixes = append(sortedPrefixes, prefix)
	}
	sort.Strings(sortedPrefixes)

	// Create sorted map for template
	sortedMap := make(map[string]string)
	for _, prefix := range sortedPrefixes {
		sortedMap[prefix] = regionMap[prefix]
		fmt.Fprintf(os.Stderr, "  %s -> %s\n", prefix, regionMap[prefix])
	}

	// Generate output
	tmpl, err := template.New("output").Parse(outputTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	// Write to file
	outputFile, err := os.Create("aws_region_map_generated.go")
	if err != nil {
		log.Fatalf("Failed to create output file: %v", err)
	}
	defer outputFile.Close()

	if err := tmpl.Execute(outputFile, sortedMap); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}
	outputFile.Close()

	// Run gofmt on the generated file
	cmd := exec.Command("gofmt", "-w", "aws_region_map_generated.go")
	if err := cmd.Run(); err != nil {
		log.Printf("Warning: Failed to run gofmt: %v", err)
	}

	fmt.Fprintf(os.Stderr, "\nGenerated mapping for %d prefixes to aws_region_map_generated.go\n", len(regionMap))
}
