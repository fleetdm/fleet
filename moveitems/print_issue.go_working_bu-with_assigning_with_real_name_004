package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"strconv"

	"github.com/shurcooL/githubv4"
	"golang.org/x/oauth2"
)

const (
	owner           = "fleetdm"
	repo            = "fleet"
	project67Number = 67
	project71Number = 71
)

type AddProjectV2ItemByIdInput struct {
	ProjectID githubv4.ID `json:"projectId"`
	ContentID githubv4.ID `json:"contentId"`
}

func main() {
	if len(os.Args) != 4 {
		log.Fatalf("Usage: go run main.go <issue_number> <username> <milestone>")
	}
	issueNumber, err := strconv.Atoi(os.Args[1])
	if err != nil {
		log.Fatalf("Invalid issue number: %v", err)
	}

	// Map real names to GitHub logins
	realNameToLogin := map[string]string{
		"dante":   "dantecatalfamo",
		"eric":    "eashaw",
		"victor":  "getvictor",
		"jacob":   "jacobshandling",
		"juan":    "juan-fdz-hawa",
		"lucas":   "lucasmrod",
		"rachael": "rachaelshaw",
		"reed":    "xpkoala",
		"sharon":  "sharon-fdm",
	}

	inputName := os.Args[2]

	// Resolve to GitHub login if known
	username, ok := realNameToLogin[inputName]
	if !ok {
		username = inputName // fallback to raw input if not mapped
	}

	milestone := os.Args[3]

	token := os.Getenv("GITHUB_TOKEN")
	if token == "" {
		log.Fatal("Please set the GITHUB_TOKEN environment variable")
	}

	src := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})
	httpClient := oauth2.NewClient(context.Background(), src)
	client := githubv4.NewClient(httpClient)

	// Fetch project 71 ID dynamically
	project71ID, err := fetchProjectID(client, owner, project71Number)
	if err != nil {
		log.Fatalf("Failed to fetch project 71 ID: %v", err)
	}

	// Fetch issue info
	issueID, issueTitle, issueURL, err := fetchIssue(client, owner, repo, issueNumber)
	if err != nil {
		log.Fatalf("Failed to fetch issue: %v", err)
	}

	fmt.Printf("Issue Title: %s\nIssue URL: %s\n", issueTitle, issueURL)

	fmt.Print("Adding this issue from Project 67 to Project 71... ")

	// Add issue to project 71
	err = addIssueToProject(client, project71ID, issueID)
	if err != nil {
		log.Fatalf("Failed to add issue to Project 71: %v", err)
	}
	fmt.Println("‚úÖ Issue added to Project 71")

	_ = printIssueDetails(client, issueID)

	err = assignUserToIssue(client, issueID, username)
	if err != nil {
		log.Fatalf("Failed to assign user: %v", err)
	}
	fmt.Println("‚úÖ User assigned")

	/*	err = removeIssueFromProject67(client, issueID)
		if err != nil {
			log.Fatalf("Error removing issue from Project 67: %v", err)
		}*/

	err = setIssueMilestone(client, issueID, milestone)
	if err != nil {
		log.Fatalf("Error setting milestone: %v", err)
	}

	return
}

func fetchProjectID(client *githubv4.Client, orgLogin string, projectNumber int) (githubv4.ID, error) {
	var query struct {
		Organization struct {
			ProjectV2 struct {
				ID githubv4.ID
			} `graphql:"projectV2(number: $number)"`
		} `graphql:"organization(login: $login)"`
	}

	variables := map[string]interface{}{
		"login":  githubv4.String(orgLogin),
		"number": githubv4.Int(projectNumber),
	}

	err := client.Query(context.Background(), &query, variables)
	if err != nil {
		return "", err
	}
	return query.Organization.ProjectV2.ID, nil
}

func fetchIssue(client *githubv4.Client, owner, repo string, issueNumber int) (githubv4.ID, string, string, error) {
	var query struct {
		Repository struct {
			Issue struct {
				ID    githubv4.ID
				Title string
				URL   string
			} `graphql:"issue(number: $number)"`
		} `graphql:"repository(owner: $owner, name: $name)"`
	}

	variables := map[string]interface{}{
		"owner":  githubv4.String(owner),
		"name":   githubv4.String(repo),
		"number": githubv4.Int(issueNumber),
	}

	err := client.Query(context.Background(), &query, variables)
	if err != nil {
		return "", "", "", err
	}
	return query.Repository.Issue.ID, query.Repository.Issue.Title, query.Repository.Issue.URL, nil
}

func addIssueToProject(client *githubv4.Client, projectID, contentID githubv4.ID) error {
	var mutation struct {
		AddProjectV2ItemById struct {
			Item struct {
				ID githubv4.ID
			}
		} `graphql:"addProjectV2ItemById(input: $input)"`
	}

	input := AddProjectV2ItemByIdInput{
		ProjectID: projectID,
		ContentID: contentID,
	}

	return client.Mutate(context.Background(), &mutation, input, nil)
}

func printIssueDetails(client *githubv4.Client, issueID githubv4.ID) error {
	var query struct {
		Node struct {
			Issue struct {
				Number int
				Title  string
				URL    string
			} `graphql:"... on Issue"`
		} `graphql:"node(id: $id)"`
	}

	variables := map[string]interface{}{
		"id": issueID,
	}

	err := client.Query(context.Background(), &query, variables)
	if err != nil {
		return fmt.Errorf("failed to fetch issue details: %v", err)
	}

	fmt.Printf("üßæ Issue #%d\nüîó %s\nüìù %s\n", query.Node.Issue.Number, query.Node.Issue.URL, query.Node.Issue.Title)
	return nil
}

func confirmAssignee(client *githubv4.Client, issueID, expectedUserID githubv4.ID) error {
	var query struct {
		Node struct {
			Issue struct {
				Assignees struct {
					Nodes []struct {
						ID    githubv4.ID
						Login string
					}
				} `graphql:"assignees(first: 10)"`
			} `graphql:"... on Issue"`
		} `graphql:"node(id: $id)"`
	}

	err := client.Query(context.Background(), &query, map[string]interface{}{
		"id": issueID,
	})
	if err != nil {
		return fmt.Errorf("failed to fetch assignees: %v", err)
	}

	fmt.Println("üîç Assignees after mutation:")
	for _, a := range query.Node.Issue.Assignees.Nodes {
		fmt.Printf(" - %s (%s)\n", a.Login, a.ID)
		if a.ID == expectedUserID {
			fmt.Println("‚úÖ Assignment confirmed.")
			return nil
		}
	}

	return fmt.Errorf("‚ùå Assignment not confirmed ‚Äî user is not listed as assignee")
}

func fetchUserID(client *githubv4.Client, login string) (githubv4.ID, error) {
	var query struct {
		User struct {
			ID githubv4.ID // This is the new global Relay ID (starts with "U_")
		} `graphql:"user(login: $login)"`
	}

	variables := map[string]interface{}{
		"login": githubv4.String(login),
	}

	err := client.Query(context.Background(), &query, variables)
	if err != nil {
		return "", err
	}

	// Print the user ID for debugging:
	fmt.Printf("Fetched user ID for %s: %s\n", login, query.User.ID)

	return query.User.ID, nil
}

func assignUserToIssue(client *githubv4.Client, issueID githubv4.ID, assigneeLogin string) error {
	token := os.Getenv("GITHUB_TOKEN")
	if token == "" {
		return fmt.Errorf("GITHUB_TOKEN is not set")
	}

	fmt.Println("üîç Fetching user global ID via GraphQL REST API...")

	// Build GraphQL query to get next_global_id
	queryPayload := fmt.Sprintf(`{
      "query": "query($login: String!) { user(login: $login) { id login databaseId } }",
      "variables": {
        "login": "%s"
      }
    }`, assigneeLogin)

	// Run curl to get the user ID
	cmd := exec.Command("curl",
		"-s",
		"-X", "POST",
		"-H", "Authorization: bearer "+token,
		"-H", "Content-Type: application/json",
		"https://api.github.com/graphql",
		"-d", queryPayload)
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to run curl for user ID: %v", err)
	}

	// Parse the output JSON to get the user ID
	var result struct {
		Data struct {
			User struct {
				ID         string `json:"id"`
				Login      string `json:"login"`
				DatabaseID int    `json:"databaseId"`
			} `json:"user"`
		} `json:"data"`
	}
	if err := json.Unmarshal(output, &result); err != nil {
		return fmt.Errorf("failed to parse user ID JSON: %v", err)
	}

	userID := result.Data.User.ID
	if userID == "" {
		return fmt.Errorf("user ID not found for login %s", assigneeLogin)
	}

	fmt.Printf("‚úÖ Fetched user global ID: %s\n", userID)

	// Build GraphQL mutation payload to assign
	mutationPayload := fmt.Sprintf(`{
      "query": "mutation($issueId: ID!, $assigneeIds: [ID!]!) { addAssigneesToAssignable(input: {assignableId: $issueId, assigneeIds: $assigneeIds}) { assignable { assignees(first: 10) { nodes { login id } } } } }",
      "variables": {
        "issueId": "%s",
        "assigneeIds": ["%s"]
      }
    }`, issueID, userID)

	fmt.Println("üîß Assigning user via GraphQL REST API...")

	// Run curl to perform assignment
	assignCmd := exec.Command("curl",
		"-s",
		"-X", "POST",
		"-H", "Authorization: bearer "+token,
		"-H", "Content-Type: application/json",
		"https://api.github.com/graphql",
		"-d", mutationPayload)

	assignOutput, err := assignCmd.Output()
	if err != nil {
		return fmt.Errorf("failed to run curl for assignment: %v", err)
	}

	fmt.Println("‚úÖ Assignment response:")
	fmt.Println(string(assignOutput))

	fmt.Println("‚úÖ User assigned successfully via REST GraphQL API.")
	return nil
}

func removeIssueFromProject67(client *githubv4.Client, issueID githubv4.ID) error {
	var query struct {
		Organization struct {
			ProjectV2 struct {
				Items struct {
					Nodes []struct {
						ID      githubv4.ID
						Content struct {
							Issue struct {
								ID githubv4.ID
							} `graphql:"... on Issue"`
						}
					} `graphql:"nodes"`
				} `graphql:"items(first: 100)"`
			} `graphql:"projectV2(number: $number)"`
		} `graphql:"organization(login: $login)"`
	}

	variables := map[string]interface{}{
		"login":  githubv4.String(owner),
		"number": githubv4.Int(project67Number),
	}

	err := client.Query(context.Background(), &query, variables)
	if err != nil {
		return fmt.Errorf("query Project 67 items failed: %w", err)
	}

	for _, item := range query.Organization.ProjectV2.Items.Nodes {
		if item.Content.Issue.ID == issueID {
			var mutation struct {
				DeleteProjectV2Item struct {
					DeletedItemID githubv4.ID
				} `graphql:"deleteProjectV2Item(input: $input)"`
			}

			input := struct {
				ItemID githubv4.ID `json:"itemId"`
			}{
				ItemID: item.ID,
			}

			err = client.Mutate(context.Background(), &mutation, input, nil)
			if err != nil {
				return fmt.Errorf("failed to delete project item: %w", err)
			}
			fmt.Println("‚úÖ Issue removed from Project 67")
			return nil
		}
	}

	return fmt.Errorf("issue not found in Project 67")
}

func setIssueMilestone(client *githubv4.Client, issueID githubv4.ID, milestoneTitle string) error {
	token := os.Getenv("GITHUB_TOKEN")
	if token == "" {
		return fmt.Errorf("GITHUB_TOKEN is not set")
	}

	owner := "fleetdm"
	repo := "fleet"

	// Step 1: Fetch milestones via REST API to get milestone number
	getMilestonesCmd := exec.Command("curl",
		"-s",
		"-H", "Authorization: Bearer "+token,
		"-H", "Accept: application/vnd.github+json",
		fmt.Sprintf("https://api.github.com/repos/%s/%s/milestones?state=open", owner, repo),
	)

	milestonesJSON, err := getMilestonesCmd.Output()
	if err != nil {
		return fmt.Errorf("failed to fetch milestones: %w", err)
	}

	var milestones []struct {
		Number int    `json:"number"`
		Title  string `json:"title"`
	}
	err = json.Unmarshal(milestonesJSON, &milestones)
	if err != nil {
		return fmt.Errorf("failed to parse milestones JSON: %w", err)
	}

	milestoneNumber := 0
	for _, m := range milestones {
		if m.Title == milestoneTitle {
			milestoneNumber = m.Number
			break
		}
	}
	if milestoneNumber == 0 {
		return fmt.Errorf("milestone %q not found", milestoneTitle)
	}
	fmt.Printf("‚úÖ Milestone number is %d\n", milestoneNumber)

	// Step 2: Get issue number from issueID via GraphQL
	var query struct {
		Node struct {
			Issue struct {
				Number int
			} `graphql:"... on Issue"`
		} `graphql:"node(id: $id)"`
	}
	variables := map[string]interface{}{
		"id": issueID,
	}
	err = client.Query(context.Background(), &query, variables)
	if err != nil {
		return fmt.Errorf("failed to get issue number: %w", err)
	}
	issueNumber := query.Node.Issue.Number

	// Step 3: Set milestone using REST API PATCH
	patchData := fmt.Sprintf(`{"milestone": %d}`, milestoneNumber)
	setMilestoneCmd := exec.Command("curl",
		"-s",
		"-X", "PATCH",
		"-H", "Authorization: Bearer "+token,
		"-H", "Accept: application/vnd.github+json",
		"-H", "Content-Type: application/json",
		"-d", patchData,
		fmt.Sprintf("https://api.github.com/repos/%s/%s/issues/%d", owner, repo, issueNumber),
	)

	patchOutput, err := setMilestoneCmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to set milestone: %w, output: %s", err, patchOutput)
	}

	fmt.Println("‚úÖ Milestone set mutation completed.")

	// Step 4: Verify milestone via GraphQL
	var verifyQuery struct {
		Node struct {
			Issue struct {
				Milestone struct {
					Title string
				}
			} `graphql:"... on Issue"`
		} `graphql:"node(id: $id)"`
	}
	err = client.Query(context.Background(), &verifyQuery, variables)
	if err != nil {
		return fmt.Errorf("failed to verify milestone: %w", err)
	}

	if verifyQuery.Node.Issue.Milestone.Title == milestoneTitle {
		fmt.Printf("‚úÖ Verified milestone: \"%s\"\n", milestoneTitle)
		return nil
	}

	return fmt.Errorf("‚ùå Milestone verification failed: expected %q but found %q",
		milestoneTitle, verifyQuery.Node.Issue.Milestone.Title)
}
