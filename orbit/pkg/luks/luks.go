package luks

import (
	"errors"
	"fmt"
	"os/exec"
	"regexp"

	"github.com/fleetdm/fleet/v4/orbit/pkg/dialog"
)

type KeyEscrower interface {
	SendLinuxKeyEscrowResponse(LuksResponse) error
	DeleteEscrowedKey(keySlot uint) error
}

type LuksRunner struct {
	escrower KeyEscrower
	notifier dialog.Dialog //nolint:structcheck,unused
}

type LuksResponse struct {
	// Passphrase is a newly created passphrase generated by fleetd for securing the LUKS volume.
	// This passphrase will be securely escrowed to the server.
	Passphrase string

	// KeySlot specifies the LUKS key slot where this new passphrase was created.
	// It is currently not used, but may be useful in the future for passphrase rotation.
	KeySlot *uint

	// Salt is the salt used to generate the LUKS key.
	Salt string

	// Err is the error message that occurred during the escrow process.
	Err string
}

func New(escrower KeyEscrower) *LuksRunner {
	return &LuksRunner{
		escrower: escrower,
	}
}

func extractJSON(input []byte) ([]byte, error) {
	// Regular expression to extract JSON
	re := regexp.MustCompile(`(?s)\{.*\}`)
	match := re.FindString(string(input))
	if match == "" {
		return nil, errors.New("no JSON found")
	}
	return []byte(match), nil
}

func isInstalled(toolName string) bool { //nolint:unused
	path, err := exec.LookPath(toolName)
	if err != nil {
		return false
	}
	return path != ""
}

// withInstalled checks that all listed tools are installed before calling fn
// otherwise errors out.
func checkInstalled(tools []string, fn func() error) error { //nolint:unused
	for _, tool := range tools {
		if !isInstalled(tool) {
			return fmt.Errorf("%s is not installed", tool)
		}
	}
	return fn()
}
