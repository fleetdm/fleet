{
  "versions": [
    {
      "version": "11.38.5",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name LIKE 'Postman %' AND publisher = 'Postman';"
      },
      "installer_url": "https://dl.pstmn.io/download/version/11.38.5/windows_64",
      "install_script_ref": "9bdf51d7",
      "uninstall_script_ref": "c7fb08b5",
      "sha256": "37ed3a534ea46b1b7899b8b31299f8c015c59630d3cbb4b50df73fdf1d4d97e4"
    }
  ],
  "refs": {
    "9bdf51d7": "$softwareName = \"postman\"\n$arguments = \"--silent\"\n$exeFilePath = \"${env:INSTALLER_PATH}\"\n$taskName = \"fleet-install-$softwareName.msix\"\n$scriptPath = \"$env:PUBLIC\\install-$softwareName.ps1\"\n$logFile = \"$env:PUBLIC\\install-output-$softwareName.txt\"\n$exitCodeFile = \"$env:PUBLIC\\install-exitcode-$softwareName.txt\"\n\n$userScript = @\"\n`$exeFilePath = \"$exeFilePath\"\n`$arguments = \"$arguments\"\n`$logFile = \"$logFile\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\n\nStart-Transcript -Path `$logFile -Append\n\ntry {\n    `$exeFilename = Split-Path `$exeFilePath -leaf\n    `$exePath = \"`${env:PUBLIC}\\`$exeFilename\"\n    \u0026 `$exePath `$arguments\n} catch {\n    Write-Host \"Error: `$_.Exception.Message\"\n    `$exitCode = 1\n} finally {\n    Set-Content -Path `$exitCodeFile -Value `$\n}\n\nStop-Transcript\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            Write-Output \"Interactive user detected: $userName\"\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Write the uninstall script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Copy the installer to a public folder so that all can access it\n    # users\n    $exeFilename = Split-Path $exeFilePath -leaf\n    Copy-Item -Path $exeFilePath -Destination \"${env:PUBLIC}\" -Force\n    $exeFilePath = \"${env:PUBLIC}\\$exeFilename\"\n\n    # Build task action: run script, redirect stdout/stderr to log file\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\" *\u003e `\"$logFile`\" 2\u003e\u00261\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Show task output\n    if (Test-Path $logFile) {\n        Write-Host \"`n--- Scheduled Task Output ---\"\n        Get-Content $logFile | Write-Host\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n        Write-Host \"`nScheduled task exit code: $exitCode\"\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Write-Host \"Cleaning up...\"\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode",
    "c7fb08b5": "$softwareName = \"Postman\"\n$productKey = \"Postman\"\n$taskName = \"fleet-uninstall-$softwareName\"\n$scriptPath = \"$env:PUBLIC\\uninstall-$softwareName.ps1\"\n$logFile = \"$env:PUBLIC\\uninstall-output-$softwareName.txt\"\n$exitCodeFile = \"$env:PUBLIC\\uninstall-exitcode-$softwareName.txt\"\n\n# Embedded uninstall script\n$userScript = @\"\n`$userKey = \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$productKey\"\n`$exitCode = 0\n`$logFile = \"$logFile\"\n`$exitCodeFile = \"$exitCodeFile\"\n\nStart-Transcript -Path \"$logFile\" -Append\n\ntry {\n    `$key = Get-ItemProperty -Path `$userKey -ErrorAction Stop\n\n    `$uninstallCommand = if (`$key.QuietUninstallString) {\n        `$key.QuietUninstallString\n    } else {\n        `$key.UninstallString\n    }\n\n    `$splitArgs = `$uninstallCommand.Split('\"')\n    if (`$splitArgs.Length -gt 1) {\n        if (`$splitArgs.Length -eq 3) {\n            `$uninstallArgs = `$splitArgs[2].Trim()\n        } elseif (`$splitArgs.Length -gt 3) {\n            Throw \"Uninstall command contains multiple quoted strings. Please update the uninstall script.`nUninstall command: `$uninstallCommand\"\n        }\n        `$uninstallCommand = `$splitArgs[1]\n    }\n\n    Write-Host \"Uninstall command: `$uninstallCommand\"\n    Write-Host \"Uninstall args: `$uninstallArgs\"\n\n    `$processOptions = @{\n        FilePath = `$uninstallCommand\n        PassThru = `$true\n        Wait     = `$true\n    }\n\n    if (`$uninstallArgs -ne '') {\n        `$processOptions.ArgumentList = \"`$uninstallArgs\"\n    }\n\n    `$process = Start-Process @processOptions\n    `$exitCode = `$process.ExitCode\n    Write-Host \"Uninstall exit code: `$exitCode\"\n}\ncatch {\n    Write-Host \"Error: `$_.Exception.Message\"\n    `$exitCode = 1\n}\nfinally {\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\n\nStop-Transcript\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            Write-Output \"Interactive user detected: $userName\"\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Write the uninstall script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script, redirect stdout/stderr to log file\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\" *\u003e `\"$logFile`\" 2\u003e\u00261\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Show task output\n    if (Test-Path $logFile) {\n        Write-Host \"`n--- Scheduled Task Output ---\"\n        Get-Content $logFile | Write-Host\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n        Write-Host \"`nScheduled task exit code: $exitCode\"\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Write-Host \"Cleaning up...\"\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode\n"
  }
}