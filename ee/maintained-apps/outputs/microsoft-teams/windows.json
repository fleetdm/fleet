{
  "versions": [
    {
      "version": "25306.804.4102.7193",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name = 'Microsoft Teams' AND publisher = 'Microsoft Corporation';"
      },
      "installer_url": "https://installer.teams.static.microsoft/production-windows-x64/25306.804.4102.7193/MSTeams-x64.msix",
      "install_script_ref": "a90fa842",
      "uninstall_script_ref": "8c408748",
      "sha256": "7bd9be340d47eabaaaa105b819a29f86cb5c1c9038874e1f0f17cd5cde92839f",
      "default_categories": [
        "Communication"
      ]
    }
  ],
  "refs": {
    "8c408748": "$softwareName = \"MSTeams-x64\"\n$packageName = \"MSTeams\"\n$taskName = \"fleet-uninstall-$softwareName.msix\"\n$scriptPath = \"$env:PUBLIC\\uninstall-$softwareName.ps1\"\n$exitCodeFile = \"$env:PUBLIC\\uninstall-exitcode-$softwareName.txt\"\n\n$userScript = @\"\n`$packageName = \"$packageName\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\n\ntry {\n    Write-Host \"=== Teams Uninstallation Start ===\"\n\n    # Remove for current user\n    Write-Host \"Removing package for current user...\"\n    Remove-AppxPackage -Package (Get-AppxPackage -Name `$packageName).PackageFullName -ErrorAction Stop\n    Write-Host \"Removed for current user\"\n\n    # Also remove provisioned package for all future users\n    Write-Host \"Removing provisioned package for all future users...\"\n    Get-AppxProvisionedPackage -Online | Where-Object { `$_.DisplayName -eq `$packageName } | Remove-AppxProvisionedPackage -Online -ErrorAction Stop\n    Write-Host \"Removed provisioned package\"\n\n    Write-Host \"=== Uninstallation Successful ===\"\n} catch {\n    Write-Host \"=== Uninstallation Failed ===\"\n    Write-Host \"Error: `$(`$_.Exception.Message)\"\n    `$exitCode = 1\n} finally {\n    Write-Host \"Exit Code: `$exitCode\"\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Write the uninstall script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script (output goes to stdout for Fleet)\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\"\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode",
    "a90fa842": "$softwareName = \"MSTeams-x64\"\n$msixPath = \"${env:INSTALLER_PATH}\"\n$taskName = \"fleet-install-$softwareName.msix\"\n$scriptPath = \"$env:PUBLIC\\install-$softwareName.ps1\"\n$exitCodeFile = \"$env:PUBLIC\\install-exitcode-$softwareName.txt\"\n\n$userScript = @\"\n`$msixPath = \"$msixPath\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\n\ntry {\n    Write-Host \"=== Teams Installation Start ===\"\n    Write-Host \"MSIX Path: `$msixPath\"\n\n    # Provision for all future users\n    Write-Host \"[1/3] Provisioning for all future users...\"\n    Add-AppProvisionedPackage -Online -PackagePath `$msixPath -SkipLicense -ErrorAction Stop\n    Write-Host \"[1/3] Provisioning complete\"\n\n    # Also install for current user so osquery can detect it immediately\n    Write-Host \"[2/3] Installing for current user...\"\n    Add-AppxPackage -Path `$msixPath -ErrorAction Stop\n    Write-Host \"[2/3] Installation complete\"\n\n    # Poll for package registration (up to 30 seconds)\n    Write-Host \"[3/3] Polling for registration (max 30s)...\"\n    `$maxAttempts = 30\n    `$attempt = 0\n    `$installed = `$null\n\n    while (`$attempt -lt `$maxAttempts) {\n        `$installed = Get-AppxPackage -Name \"MSTeams\" -ErrorAction SilentlyContinue\n        if (`$installed) {\n            Write-Host \"[3/3] Package registered after `$attempt seconds\"\n            break\n        }\n        Start-Sleep -Seconds 1\n        `$attempt++\n    }\n\n    if (-not `$installed) {\n        Write-Host \"[3/3] ERROR: Package not registered after `$attempt seconds\"\n        `$exitCode = 1\n    } else {\n        Write-Host \"=== Installation Successful ===\"\n        Write-Host \"Package: `$(`$installed.PackageFullName)\"\n        Write-Host \"Version: `$(`$installed.Version)\"\n    }\n} catch {\n    Write-Host \"=== Installation Failed ===\"\n    Write-Host \"Error: `$(`$_.Exception.Message)\"\n    `$exitCode = 1\n} finally {\n    Write-Host \"Exit Code: `$exitCode\"\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Write the install script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script (output goes to stdout for Fleet)\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\"\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force | Out-Null\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n    } else {\n        $exitCode = 1\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode\n"
  }
}
