{
  "versions": [
    {
      "version": "25306.804.4102.7193",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name = 'Microsoft Teams' AND publisher = 'Microsoft Corporation';"
      },
      "installer_url": "https://installer.teams.static.microsoft/production-windows-x64/25306.804.4102.7193/MSTeams-x64.msix",
      "install_script_ref": "4de172ca",
      "uninstall_script_ref": "b7ac1c2f",
      "sha256": "7bd9be340d47eabaaaa105b819a29f86cb5c1c9038874e1f0f17cd5cde92839f",
      "default_categories": [
        "Communication"
      ]
    }
  ],
  "refs": {
    "4de172ca": "$softwareName = \"MSTeams-x64\"\n$msixPath = \"${env:INSTALLER_PATH}\"\n$taskName = \"fleet-install-$softwareName.msix\"\n$scriptPath = \"$env:PUBLIC\\install-$softwareName.ps1\"\n$logFile = \"$env:PUBLIC\\install-output-$softwareName.txt\"\n$exitCodeFile = \"$env:PUBLIC\\install-exitcode-$softwareName.txt\"\n\n$userScript = @\"\n`$msixPath = \"$msixPath\"\n`$logFile = \"$logFile\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\n\nStart-Transcript -Path `$logFile -Append\n\ntry {\n    Add-AppProvisionedPackage -Online -PackagePath `$msixPath -SkipLicense\n} catch {\n    Write-Host \"Error: `$_.Exception.Message\"\n    `$exitCode = 1\n} finally {\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\n\nStop-Transcript\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            Write-Output \"Interactive user detected: $userName\"\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Write the uninstall script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script, redirect stdout/stderr to log file\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\" *> `\"$logFile`\" 2>&1\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Show task output\n    if (Test-Path $logFile) {\n        Write-Host \"`n--- Scheduled Task Output ---\"\n        Get-Content $logFile | Write-Host\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n        Write-Host \"`nScheduled task exit code: $exitCode\"\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Write-Host \"Cleaning up...\"\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode",
    "b7ac1c2f": "$softwareName = \"MSTeams-x64\"\n$packageName = \"MSTeams\"\n$taskName = \"fleet-uninstall-$softwareName.msix\"\n$scriptPath = \"$env:PUBLIC\\uninstall-$softwareName.ps1\"\n$logFile = \"$env:PUBLIC\\uninstall-output-$softwareName.txt\"\n$exitCodeFile = \"$env:PUBLIC\\uninstall-exitcode-$softwareName.txt\"\n\n$userScript = @\"\n`$packageName = \"$packageName\"\n`$logFile = \"$logFile\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\n\nStart-Transcript -Path `$logFile -Append\n\ntry {\n    Remove-AppxPackage -Package (Get-AppxPackage -Name `$packageName).PackageFullName\n} catch {\n    Write-Host \"Error: `$_.Exception.Message\"\n    `$exitCode = 1\n} finally {\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\n\nStop-Transcript\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            Write-Output \"Interactive user detected: $userName\"\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Write the uninstall script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script, redirect stdout/stderr to log file\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\" *> `\"$logFile`\" 2>&1\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Show task output\n    if (Test-Path $logFile) {\n        Write-Host \"`n--- Scheduled Task Output ---\"\n        Get-Content $logFile | Write-Host\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n        Write-Host \"`nScheduled task exit code: $exitCode\"\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Write-Host \"Cleaning up...\"\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode"
  }
}
