{
  "versions": [
    {
      "version": "1.2.79.425.g1d0fcf61",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name = 'Spotify' AND publisher = 'Spotify AB';"
      },
      "installer_url": "https://upgrade.scdn.co/upgrade/client/win32-x86_64/spotify_installer-1.2.79.425.g1d0fcf61-256.exe",
      "install_script_ref": "1d2da8d3",
      "uninstall_script_ref": "e2b14e89",
      "sha256": "f971fe8e2e0591ea7352fd8f459639486af0b4dade12721d12dff8dd3c518689",
      "default_categories": [
        "Productivity"
      ]
    }
  ],
  "refs": {
    "1d2da8d3": "# Learn more about .exe install scripts:\n# http://fleetdm.com/learn-more-about/exe-install-scripts\n\n$exeFilePath = \"${env:INSTALLER_PATH}\"\n$taskName = \"fleet-install-spotify\"\n$scriptPath = \"$env:PUBLIC\\install-spotify.ps1\"\n$exitCodeFile = \"$env:PUBLIC\\install-exitcode-spotify.txt\"\n\n$userScript = @\"\n`$exeFilePath = \"$exeFilePath\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\n\ntry {\n    Write-Host \"=== Spotify Installation Start ===\"\n    Write-Host \"Installer Path: `$exeFilePath\"\n\n    # Verify installer file exists\n    if (-not (Test-Path `$exeFilePath)) {\n        throw \"Installer file not found at: `$exeFilePath\"\n    }\n\n    # Spotify installer supports /silent for silent installation\n    Write-Host \"Starting installation with /silent...\"\n    `$processOptions = @{\n        FilePath = \"`$exeFilePath\"\n        ArgumentList = \"/silent\"\n        PassThru = `$true\n        Wait = `$true\n        NoNewWindow = `$true\n    }\n    \n    `$process = Start-Process @processOptions\n    \n    if (`$null -eq `$process) {\n        throw \"Failed to start installer process\"\n    }\n    \n    `$exitCode = `$process.ExitCode\n    Write-Host \"Install exit code: `$exitCode\"\n    \n    # If /silent fails, try /S as fallback\n    if (`$exitCode -ne 0) {\n        Write-Host \"Installation with /silent failed (exit code: `$exitCode), trying /S as fallback...\"\n        `$fallbackOptions = @{\n            FilePath = \"`$exeFilePath\"\n            ArgumentList = \"/S\"\n            PassThru = `$true\n            Wait = `$true\n            NoNewWindow = `$true\n        }\n        `$fallbackProcess = Start-Process @fallbackOptions\n        if (`$null -ne `$fallbackProcess) {\n            `$exitCode = `$fallbackProcess.ExitCode\n            Write-Host \"Fallback install exit code: `$exitCode\"\n        }\n    }\n    \n    if (`$exitCode -eq 0) {\n        Write-Host \"=== Installation Successful ===\"\n    } else {\n        Write-Host \"=== Installation Failed ===\"\n    }\n} catch {\n    Write-Host \"=== Installation Failed ===\"\n    Write-Host \"Error: `$(`$_.Exception.Message)\"\n    `$exitCode = 1\n} finally {\n    Write-Host \"Exit Code: `$exitCode\"\n    Set-Content -Path `$exitCodeFile -Value `$exitCode -Force\n}\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n$publicExePath = $null\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Copy installer to public folder so user can access it\n    $exeFilename = Split-Path $exeFilePath -Leaf\n    $publicExePath = \"$env:PUBLIC\\$exeFilename\"\n    Copy-Item -Path $exeFilePath -Destination $publicExePath -Force\n    $exeFilePath = $publicExePath\n\n    # Update script with correct path\n    $userScript = $userScript -replace '\"' + [regex]::Escape(${env:INSTALLER_PATH}) + '\"', \"`\"$exeFilePath`\"\"\n\n    # Write the install script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\"\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force | Out-Null\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 300) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = [int](Get-Content $exitCodeFile)\n    } else {\n        $exitCode = 1\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n    if (Test-Path $publicExePath) {\n        Remove-Item -Path $publicExePath -Force -ErrorAction SilentlyContinue\n    }\n}\n\nExit $exitCode\n\n",
    "e2b14e89": "# Attempts to locate Spotify's uninstaller from registry and execute it silently\n\n$displayName = \"Spotify\"\n$publisher = \"Spotify AB\"\n\n# Check both machine and user registry paths since Spotify can be installed user-scoped\n$paths = @(\n  'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKCU:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall'\n)\n\n$uninstall = $null\nforeach ($p in $paths) {\n  $items = Get-ItemProperty \"$p\\*\" -ErrorAction SilentlyContinue | Where-Object {\n    $_.DisplayName -and ($_.DisplayName -eq $displayName -or $_.DisplayName -like \"$displayName*\") -and ($publisher -eq \"\" -or $_.Publisher -eq $publisher)\n  }\n  if ($items) { $uninstall = $items | Select-Object -First 1; break }\n}\n\nif (-not $uninstall -or -not $uninstall.UninstallString) {\n  Write-Host \"Uninstall entry not found - may already be uninstalled\"\n  Exit 0\n}\n\n# Kill any running Spotify processes before uninstalling\nGet-Process -Name \"Spotify*\" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue\nStart-Sleep -Seconds 2\n\n$uninstallString = $uninstall.UninstallString\n$exePath = \"\"\n$arguments = \"\"\n\n# Parse the uninstall string to extract executable path and existing arguments\n# Handles both quoted and unquoted paths\nif ($uninstallString -match '^\"([^\"]+)\"(.*)') {\n    $exePath = $matches[1]\n    $arguments = $matches[2].Trim()\n} elseif ($uninstallString -match '^([^\\s]+)(.*)') {\n    $exePath = $matches[1]\n    $arguments = $matches[2].Trim()\n} else {\n    Write-Host \"Error: Could not parse uninstall string: $uninstallString\"\n    Exit 1\n}\n\n# Build argument list array, preserving existing arguments and adding /silent\n$argumentList = @()\nif ($arguments -ne '') {\n    # Split existing arguments and add them\n    $argumentList += $arguments -split '\\s+'\n}\n# Add /silent if not already present\nif ($argumentList -notcontains \"/silent\") {\n    $argumentList += \"/silent\"\n}\n\nWrite-Host \"Uninstall executable: $exePath\"\nWrite-Host \"Uninstall arguments: $($argumentList -join ' ')\"\n\ntry {\n    $processOptions = @{\n        FilePath = $exePath\n        ArgumentList = $argumentList\n        NoNewWindow = $true\n        PassThru = $true\n        Wait = $true\n    }\n    \n    $process = Start-Process @processOptions\n    $exitCode = $process.ExitCode\n    \n    Write-Host \"Uninstall exit code: $exitCode\"\n    Exit $exitCode\n} catch {\n    Write-Host \"Error running uninstaller: $_\"\n    Exit 1\n}\n\n"
  }
}
