{
  "versions": [
    {
      "version": "11.2.1495.0",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name = 'Microsoft Company Portal' AND publisher = 'Microsoft Corporation';"
      },
      "installer_url": "https://download.microsoft.com/download/ac93b367-7b17-4838-a079-c6f3377bf582/CompanyPortal-Universal-Production_x64_x86_ARM_ARM64.appxupload_Windows10_PreinstallKit.zip",
      "install_script_ref": "46aaefa3",
      "uninstall_script_ref": "b6b4f472",
      "sha256": "2ced91d35bf33ccd9e8e76377bf1f24e41b6238547ab43675955eed1757a8f9b",
      "default_categories": [
        "Productivity"
      ]
    }
  ],
  "refs": {
    "46aaefa3": "$softwareName = \"MicrosoftCompanyPortal\"\n$zipPath = \"${env:INSTALLER_PATH}\"\n$taskName = \"fleet-install-$softwareName.zip\"\n$scriptPath = \"$env:PUBLIC\\install-$softwareName.ps1\"\n$exitCodeFile = \"$env:PUBLIC\\install-exitcode-$softwareName.txt\"\n$logFile = \"$env:PUBLIC\\install-log-$softwareName.txt\"\n\n$userScript = @\"\n`$ErrorActionPreference = \"Stop\"\n`$zipPath = \"$zipPath\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$logFile = \"$logFile\"\n`$exitCode = 0\n`$extractPath = \"$env:TEMP\\fleet-companyportal-extract\"\n\n# Redirect all output to log file and stdout\nfunction Write-Log {\n    param([string]`$Message)\n    `$timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n    `$logMessage = \"[`$timestamp] `$Message\"\n    Add-Content -Path `$logFile -Value `$logMessage -Force\n    Write-Host `$Message\n}\n\ntry {\n    Write-Log \"=== Company Portal Installation Start ===\"\n    Write-Log \"Zip Path: `$zipPath\"\n    Write-Log \"Extract Path: `$extractPath\"\n\n    # Verify zip file exists\n    if (-not (Test-Path `$zipPath)) {\n        throw \"Zip file not found: `$zipPath\"\n    }\n    Write-Log \"Zip file exists\"\n\n    # Extract the zip file\n    Write-Log \"[1/4] Extracting zip file...\"\n    if (Test-Path `$extractPath) {\n        Remove-Item -Path `$extractPath -Recurse -Force -ErrorAction SilentlyContinue\n    }\n    New-Item -ItemType Directory -Path `$extractPath -Force | Out-Null\n    \n    Add-Type -AssemblyName System.IO.Compression.FileSystem\n    [System.IO.Compression.ZipFile]::ExtractToDirectory(`$zipPath, `$extractPath)\n    Write-Log \"[1/4] Extraction complete\"\n\n    # Find the nested appx file dynamically\n    Write-Log \"Searching for appx/appxbundle files...\"\n    `$appxFiles = Get-ChildItem -Path `$extractPath -Recurse -Filter \"*.appxbundle\" -ErrorAction SilentlyContinue\n    if (-not `$appxFiles) {\n        `$appxFiles = Get-ChildItem -Path `$extractPath -Recurse -Filter \"*.appx\" -ErrorAction SilentlyContinue\n    }\n    \n    if (-not `$appxFiles -or `$appxFiles.Count -eq 0) {\n        throw \"No appx or appxbundle file found in extracted zip\"\n    }\n    \n    `$appxPath = `$appxFiles[0].FullName\n    Write-Log \"Found appx file: `$appxPath\"\n\n    # Provision for all future users (this works in headless environments)\n    Write-Log \"[2/4] Provisioning for all future users...\"\n    try {\n        `$provisionResult = Add-AppProvisionedPackage -Online -PackagePath `$appxPath -SkipLicense -ErrorAction Stop 2>&1\n        Write-Log \"Provisioning output: `$provisionResult\"\n        Write-Log \"[2/4] Provisioning complete\"\n    } catch {\n        Write-Log \"ERROR: Provisioning failed: `$(`$_.Exception.Message)\"\n        throw\n    }\n\n    # Also install for current user so osquery can detect it immediately\n    # Note: This may fail in headless/CI environments, but provisioning is sufficient\n    Write-Log \"[3/4] Installing for current user...\"\n    `$userInstallSuccess = `$false\n    try {\n        `$installResult = Add-AppxPackage -Path `$appxPath -ErrorAction Stop 2>&1\n        Write-Log \"Installation output: `$installResult\"\n        `$userInstallSuccess = `$true\n        Write-Log \"[3/4] Installation complete\"\n    } catch {\n        Write-Log \"WARNING: User installation failed (may be headless environment): `$(`$_.Exception.Message)\"\n        Write-Log \"[3/4] Continuing anyway - package is provisioned for future users\"\n        # Don't fail the script if user install fails - provisioning is the important part\n    }\n\n    # Poll for package registration (up to 30 seconds)\n    # In headless environments, the package may not show up in Get-AppxPackage\n    # but it's still provisioned and will appear for future users\n    Write-Log \"[4/4] Polling for registration (max 30s)...\"\n    `$maxAttempts = 30\n    `$attempt = 0\n    `$installed = `$null\n\n    while (`$attempt -lt `$maxAttempts) {\n        `$installed = Get-AppxPackage -Name \"Microsoft.CompanyPortal\" -ErrorAction SilentlyContinue\n        if (`$installed) {\n            Write-Log \"[4/4] Package registered after `$attempt seconds\"\n            break\n        }\n        Start-Sleep -Seconds 1\n        `$attempt++\n    }\n\n    # Check if package is provisioned (works even if user install failed)\n    `$provisioned = Get-AppxProvisionedPackage -Online | Where-Object { `$_.DisplayName -like \"*Company Portal*\" } | Select-Object -First 1\n    if (`$provisioned) {\n        Write-Log \"Package is provisioned: `$(`$provisioned.DisplayName)\"\n    }\n\n    if (-not `$installed -and -not `$provisioned) {\n        Write-Log \"[4/4] ERROR: Package not registered and not provisioned\"\n        `$exitCode = 1\n    } elseif (-not `$installed) {\n        # Package is provisioned but not installed for current user (likely headless environment)\n        Write-Log \"[4/4] Package is provisioned but not installed for current user (headless environment?)\"\n        Write-Log \"=== Installation Successful (Provisioned) ===\"\n        Write-Log \"Package will be available for future user logins\"\n        # Still consider this successful - provisioning is what matters\n    } else {\n        Write-Log \"=== Installation Successful ===\"\n        Write-Log \"Package: `$(`$installed.PackageFullName)\"\n        Write-Log \"Version: `$(`$installed.Version)\"\n    }\n    \n    # Give osquery time to detect the app in the programs table\n    Write-Log \"Waiting for osquery to detect app (5 seconds)...\"\n    Start-Sleep -Seconds 5\n} catch {\n    Write-Log \"=== Installation Failed ===\"\n    Write-Log \"Error: `$(`$_.Exception.Message)\"\n    Write-Log \"Stack: `$(`$_.ScriptStackTrace)\"\n    `$exitCode = 1\n} finally {\n    # Clean up extracted files\n    if (Test-Path `$extractPath) {\n        Remove-Item -Path `$extractPath -Recurse -Force -ErrorAction SilentlyContinue\n    }\n    Write-Log \"Exit Code: `$exitCode\"\n    Set-Content -Path `$exitCodeFile -Value `$exitCode -Force\n}\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    Write-Host \"=== Company Portal Install Wrapper Start ===\"\n    Write-Host \"Zip Path: $zipPath\"\n    Write-Host \"Script Path: $scriptPath\"\n    Write-Host \"Exit Code File: $exitCodeFile\"\n\n    # Wait for an interactive user to be logged on\n    Write-Host \"Waiting for interactive user...\"\n    $maxWaitAttempts = 24  # 2 minutes max\n    $waitAttempt = 0\n    $userName = $null\n    \n    while ($waitAttempt -lt $maxWaitAttempts) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            Write-Host \"Found interactive user: $userName\"\n            break\n        } else {\n            Start-Sleep -Seconds 5\n            $waitAttempt++\n        }\n    }\n    \n    if (-not $userName -or -not ($userName -like \"*\\*\")) {\n        throw \"Timeout waiting for interactive user after $($maxWaitAttempts * 5) seconds\"\n    }\n\n    # Write the install script to disk\n    Write-Host \"Writing install script to disk...\"\n    Set-Content -Path $scriptPath -Value $userScript -Force\n    Write-Host \"Script written successfully\"\n\n    # Build task action: run script (output is captured via Write-Log function)\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\"\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force | Out-Null\n\n    # Start the task\n    Write-Host \"Starting scheduled task...\"\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    Write-Host \"Waiting for task to start...\"\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n    Write-Host \"Task started successfully\"\n\n    # Wait for it to complete\n    Write-Host \"Waiting for task to complete...\"\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 300) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n    Write-Host \"Task completed with state: $state\"\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = [int](Get-Content $exitCodeFile)\n        Write-Host \"Exit code from task: $exitCode\"\n    } else {\n        Write-Host \"WARNING: Exit code file not found, assuming failure\"\n        $exitCode = 1\n    }\n    \n    # Read and display the log file (last 100 lines to avoid truncation)\n    if (Test-Path $logFile) {\n        Write-Host \"=== Task Output Log (last 100 lines) ===\"\n        $logLines = Get-Content $logFile\n        $lineCount = $logLines.Count\n        if ($lineCount -gt 100) {\n            Write-Host \"... (showing last 100 of $lineCount lines) ...\"\n            $logLines[-100..-1] | ForEach-Object { Write-Host $_ }\n        } else {\n            $logLines | ForEach-Object { Write-Host $_ }\n        }\n        Write-Host \"=== End Task Output Log ===\"\n    } else {\n        Write-Host \"WARNING: Log file not found at $logFile\"\n    }\n\n} catch {\n    Write-Host \"=== Wrapper Error ===\"\n    Write-Host \"Error: $_\"\n    Write-Host \"Stack: $($_.ScriptStackTrace)\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Write-Host \"Cleaning up scheduled task and files...\"\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n    # Keep log file for debugging, but could remove it: Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue\n    Write-Host \"=== Company Portal Install Wrapper End ===\"\n}\n\nExit $exitCode\n\n",
    "b6b4f472": "$softwareName = \"MicrosoftCompanyPortal\"\n$packageName = \"Microsoft.CompanyPortal\"\n$taskName = \"fleet-uninstall-$softwareName.zip\"\n$scriptPath = \"$env:PUBLIC\\uninstall-$softwareName.ps1\"\n$exitCodeFile = \"$env:PUBLIC\\uninstall-exitcode-$softwareName.txt\"\n\n$userScript = @\"\n`$packageName = \"$packageName\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\n\ntry {\n    Write-Host \"=== Company Portal Uninstallation Start ===\"\n\n    # Remove for current user\n    Write-Host \"Removing package for current user...\"\n    `$package = Get-AppxPackage -Name `$packageName -ErrorAction SilentlyContinue\n    if (`$package) {\n        Remove-AppxPackage -Package `$package.PackageFullName -ErrorAction Stop\n        Write-Host \"Removed for current user\"\n    } else {\n        Write-Host \"Package not found for current user\"\n    }\n\n    # Also remove provisioned package for all future users\n    Write-Host \"Removing provisioned package for all future users...\"\n    `$provisioned = Get-AppxProvisionedPackage -Online | Where-Object { `$_.DisplayName -eq `$packageName } | Select-Object -First 1\n    if (`$provisioned) {\n        Remove-AppxProvisionedPackage -Online -PackageName `$provisioned.PackageName -ErrorAction Stop\n        Write-Host \"Removed provisioned package\"\n    } else {\n        Write-Host \"Provisioned package not found\"\n    }\n\n    Write-Host \"=== Uninstallation Successful ===\"\n} catch {\n    Write-Host \"=== Uninstallation Failed ===\"\n    Write-Host \"Error: `$(`$_.Exception.Message)\"\n    `$exitCode = 1\n} finally {\n    Write-Host \"Exit Code: `$exitCode\"\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Write the uninstall script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script (output goes to stdout for Fleet)\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\"\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode\n\n"
  }
}
