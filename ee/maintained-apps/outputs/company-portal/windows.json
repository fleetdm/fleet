{
  "versions": [
    {
      "version": "11.2.1495.0",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name = 'Microsoft.CompanyPortal' AND publisher = 'Microsoft Corporation';"
      },
      "installer_url": "https://download.microsoft.com/download/ac93b367-7b17-4838-a079-c6f3377bf582/CompanyPortal-Universal-Production_x64_x86_ARM_ARM64.appxupload_Windows10_PreinstallKit.zip",
      "install_script_ref": "f5ae6166",
      "uninstall_script_ref": "b6b4f472",
      "sha256": "2ced91d35bf33ccd9e8e76377bf1f24e41b6238547ab43675955eed1757a8f9b",
      "default_categories": [
        "Productivity"
      ]
    }
  ],
  "refs": {
    "b6b4f472": "$softwareName = \"MicrosoftCompanyPortal\"\n$packageName = \"Microsoft.CompanyPortal\"\n$taskName = \"fleet-uninstall-$softwareName.zip\"\n$scriptPath = \"$env:PUBLIC\\uninstall-$softwareName.ps1\"\n$exitCodeFile = \"$env:PUBLIC\\uninstall-exitcode-$softwareName.txt\"\n\n$userScript = @\"\n`$packageName = \"$packageName\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\n\ntry {\n    Write-Host \"=== Company Portal Uninstallation Start ===\"\n\n    # Remove for current user\n    Write-Host \"Removing package for current user...\"\n    `$package = Get-AppxPackage -Name `$packageName -ErrorAction SilentlyContinue\n    if (`$package) {\n        Remove-AppxPackage -Package `$package.PackageFullName -ErrorAction Stop\n        Write-Host \"Removed for current user\"\n    } else {\n        Write-Host \"Package not found for current user\"\n    }\n\n    # Also remove provisioned package for all future users\n    Write-Host \"Removing provisioned package for all future users...\"\n    `$provisioned = Get-AppxProvisionedPackage -Online | Where-Object { `$_.DisplayName -eq `$packageName } | Select-Object -First 1\n    if (`$provisioned) {\n        Remove-AppxProvisionedPackage -Online -PackageName `$provisioned.PackageName -ErrorAction Stop\n        Write-Host \"Removed provisioned package\"\n    } else {\n        Write-Host \"Provisioned package not found\"\n    }\n\n    Write-Host \"=== Uninstallation Successful ===\"\n} catch {\n    Write-Host \"=== Uninstallation Failed ===\"\n    Write-Host \"Error: `$(`$_.Exception.Message)\"\n    `$exitCode = 1\n} finally {\n    Write-Host \"Exit Code: `$exitCode\"\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Write the uninstall script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script (output goes to stdout for Fleet)\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\"\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode\n\n",
    "f5ae6166": "$softwareName = \"MicrosoftCompanyPortal\"\n$zipPath = \"${env:INSTALLER_PATH}\"\n$taskName = \"fleet-install-$softwareName.zip\"\n$scriptPath = \"$env:PUBLIC\\install-$softwareName.ps1\"\n$exitCodeFile = \"$env:PUBLIC\\install-exitcode-$softwareName.txt\"\n\n$userScript = @\"\n`$ErrorActionPreference = \"Stop\"\n`$zipPath = \"$zipPath\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\n`$extractPath = \"$env:TEMP\\fleet-companyportal-extract\"\n\ntry {\n    Write-Host \"=== Company Portal Installation Start ===\"\n\n    # Verify zip file exists\n    if (-not (Test-Path `$zipPath)) {\n        throw \"Zip file not found: `$zipPath\"\n    }\n\n    # Extract the zip file\n    Write-Host \"[1/4] Extracting zip file...\"\n    if (Test-Path `$extractPath) {\n        Remove-Item -Path `$extractPath -Recurse -Force -ErrorAction SilentlyContinue\n    }\n    New-Item -ItemType Directory -Path `$extractPath -Force | Out-Null\n    \n    Add-Type -AssemblyName System.IO.Compression.FileSystem\n    [System.IO.Compression.ZipFile]::ExtractToDirectory(`$zipPath, `$extractPath)\n    Write-Host \"[1/4] Extraction complete\"\n\n    # Find the nested appx file dynamically\n    `$appxFiles = Get-ChildItem -Path `$extractPath -Recurse -Filter \"*.appxbundle\" -ErrorAction SilentlyContinue\n    if (-not `$appxFiles) {\n        `$appxFiles = Get-ChildItem -Path `$extractPath -Recurse -Filter \"*.appx\" -ErrorAction SilentlyContinue\n    }\n    \n    if (-not `$appxFiles -or `$appxFiles.Count -eq 0) {\n        throw \"No appx or appxbundle file found in extracted zip\"\n    }\n    \n    `$appxPath = `$appxFiles[0].FullName\n    Write-Host \"Found appx file: `$appxPath\"\n\n    # Provision for all future users (this works in headless environments)\n    Write-Host \"[2/4] Provisioning for all future users...\"\n    Add-AppProvisionedPackage -Online -PackagePath `$appxPath -SkipLicense -ErrorAction Stop\n    Write-Host \"[2/4] Provisioning complete\"\n\n    # Also install for current user so osquery can detect it immediately\n    # Note: This may fail in headless/CI environments, but provisioning is sufficient\n    Write-Host \"[3/4] Installing for current user...\"\n    try {\n        Add-AppxPackage -Path `$appxPath -ErrorAction Stop | Out-Null\n        Write-Host \"[3/4] Installation complete\"\n    } catch {\n        Write-Host \"[3/4] User installation failed (may be headless environment), continuing...\"\n        # Don't fail the script if user install fails - provisioning is the important part\n    }\n\n    # Poll for package registration (up to 30 seconds)\n    Write-Host \"[4/4] Polling for registration (max 30s)...\"\n    `$maxAttempts = 30\n    `$attempt = 0\n    `$installed = `$null\n\n    while (`$attempt -lt `$maxAttempts) {\n        `$installed = Get-AppxPackage -Name \"Microsoft.CompanyPortal\" -ErrorAction SilentlyContinue\n        if (`$installed) {\n            Write-Host \"[4/4] Package registered after `$attempt seconds\"\n            break\n        }\n        Start-Sleep -Seconds 1\n        `$attempt++\n    }\n\n    # Check if package is provisioned (works even if user install failed)\n    `$provisioned = Get-AppxProvisionedPackage -Online | Where-Object { `$_.DisplayName -eq \"Microsoft.CompanyPortal\" } | Select-Object -First 1\n    if (-not `$installed -and -not `$provisioned) {\n        Write-Host \"[4/4] ERROR: Package not registered and not provisioned\"\n        `$exitCode = 1\n    } elseif (-not `$installed) {\n        # Package is provisioned but not installed for current user (likely headless environment)\n        Write-Host \"[4/4] Package is provisioned but not installed for current user\"\n        Write-Host \"=== Installation Successful (Provisioned) ===\"\n    } else {\n        Write-Host \"=== Installation Successful ===\"\n        Write-Host \"Package: `$(`$installed.PackageFullName)\"\n        Write-Host \"Version: `$(`$installed.Version)\"\n    }\n    \n    # Give osquery time to detect the app in the programs table\n    Start-Sleep -Seconds 5\n} catch {\n    Write-Host \"=== Installation Failed ===\"\n    Write-Host \"Error: `$(`$_.Exception.Message)\"\n    `$exitCode = 1\n} finally {\n    # Clean up extracted files\n    if (Test-Path `$extractPath) {\n        Remove-Item -Path `$extractPath -Recurse -Force -ErrorAction SilentlyContinue\n    }\n    Write-Host \"Exit Code: `$exitCode\"\n    Set-Content -Path `$exitCodeFile -Value `$exitCode -Force\n}\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Write the install script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script (output is captured via Write-Log function)\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\"\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force | Out-Null\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 300) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = [int](Get-Content $exitCodeFile)\n    } else {\n        $exitCode = 1\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode\n\n"
  }
}
