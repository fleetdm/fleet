{
  "versions": [
    {
      "version": "125.10.4",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name = 'Figma' AND publisher = 'Figma, Inc.';"
      },
      "installer_url": "https://desktop.figma.com/win/build/Figma-125.10.4.exe",
      "install_script_ref": "fb1849b8",
      "uninstall_script_ref": "e33afd6b",
      "sha256": "5e5f692733001f84c6b7d32bebcb31878448701baad6701cfbe475818c5e3cdc",
      "default_categories": [
        "Productivity"
      ]
    }
  ],
  "refs": {
    "e33afd6b": "# Attempts to locate Figma's uninstaller from registry and execute it silently\n\n$displayName = \"Figma\"\n$publisher = \"Figma, Inc.\"\n\n$paths = @(\n  'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKCU:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall'\n)\n\n$uninstall = $null\nforeach ($p in $paths) {\n  $items = Get-ItemProperty \"$p\\*\" -ErrorAction SilentlyContinue | Where-Object {\n    $_.DisplayName -and ($_.DisplayName -eq $displayName -or $_.DisplayName -like \"$displayName*\") -and ($publisher -eq \"\" -or $_.Publisher -eq $publisher)\n  }\n  if ($items) { $uninstall = $items | Select-Object -First 1; break }\n}\n\nif (-not $uninstall -or -not $uninstall.UninstallString) {\n  Write-Host \"Uninstall entry not found\"\n  Exit 0\n}\n\n# Kill any running Figma processes before uninstalling\nStop-Process -Name \"Figma\" -Force -ErrorAction SilentlyContinue\n\n$uninstallString = $uninstall.UninstallString\n$exePath = \"\"\n$arguments = \"\"\n\n# Parse the uninstall string to extract executable path and existing arguments\n# Handles both quoted and unquoted paths\nif ($uninstallString -match '^\"([^\"]+)\"(.*)') {\n    $exePath = $matches[1]\n    $arguments = $matches[2].Trim()\n} elseif ($uninstallString -match '^([^\\s]+)(.*)') {\n    $exePath = $matches[1]\n    $arguments = $matches[2].Trim()\n} else {\n    Write-Host \"Error: Could not parse uninstall string: $uninstallString\"\n    Exit 1\n}\n\n# Build argument list array, preserving existing arguments and adding -s for silent\n$argumentList = @()\nif ($arguments -ne '') {\n    # Split existing arguments and add them\n    $argumentList += $arguments -split '\\s+'\n}\n# Add -s for silent uninstall if not already present\nif ($argumentList -notcontains \"-s\" -and $argumentList -notcontains \"--silent\") {\n    $argumentList += \"-s\"\n}\n\nWrite-Host \"Uninstall executable: $exePath\"\nWrite-Host \"Uninstall arguments: $($argumentList -join ' ')\"\n\ntry {\n    $processOptions = @{\n        FilePath = $exePath\n        ArgumentList = $argumentList\n        NoNewWindow = $true\n        PassThru = $true\n        Wait = $true\n    }\n    \n    $process = Start-Process @processOptions\n    $exitCode = $process.ExitCode\n    \n    Write-Host \"Uninstall exit code: $exitCode\"\n    Exit $exitCode\n} catch {\n    Write-Host \"Error running uninstaller: $_\"\n    Exit 1\n}\n\n",
    "fb1849b8": "$softwareName = \"figma\"\n$arguments = \"-s\"\n$exeFilePath = \"${env:INSTALLER_PATH}\"\n$taskName = \"fleet-install-$softwareName.msix\"\n$scriptPath = \"$env:PUBLIC\\install-$softwareName.ps1\"\n$logFile = \"$env:PUBLIC\\install-output-$softwareName.txt\"\n$exitCodeFile = \"$env:PUBLIC\\install-exitcode-$softwareName.txt\"\n\n$userScript = @\"\n`$exeFilePath = \"$exeFilePath\"\n`$arguments = \"$arguments\"\n`$logFile = \"$logFile\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\nStart-Transcript -Path `$logFile -Append\ntry {\n    `$exeFilename = Split-Path `$exeFilePath -leaf\n    `$exePath = \"`${env:PUBLIC}\\`$exeFilename\"\n    \u0026 `$exePath `$arguments\n    `$exitCode = `$LASTEXITCODE\n    if (`$exitCode -eq 0 -or `$exitCode -eq $null) {\n        `$exitCode = 0\n    }\n} catch {\n    Write-Host \"Error: `$_.Exception.Message\"\n    `$exitCode = 1\n} finally {\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\nStop-Transcript\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            Write-Output \"Interactive user detected: $userName\"\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Write the install script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Copy the installer to a public folder so that all users can access it\n    $exeFilename = Split-Path $exeFilePath -leaf\n    Copy-Item -Path $exeFilePath -Destination \"${env:PUBLIC}\" -Force\n    $exeFilePath = \"${env:PUBLIC}\\$exeFilename\"\n\n    # Build task action: run script, redirect stdout/stderr to log file\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\" *\u003e `\"$logFile`\" 2\u003e\u00261\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Show task output\n    if (Test-Path $logFile) {\n        Write-Host \"`n--- Scheduled Task Output ---\"\n        Get-Content $logFile | Write-Host\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $taskExitCode = Get-Content $exitCodeFile\n        Write-Host \"`nScheduled task exit code: $taskExitCode\"\n        if ($taskExitCode -ne \"0\" -and $taskExitCode -ne \"\") {\n            $exitCode = [int]$taskExitCode\n            throw \"Scheduled task failed with exit code: $taskExitCode\"\n        }\n        # Wait a moment for registry to update after installation\n        Start-Sleep -Seconds 2\n    } else {\n        Write-Host \"`nWarning: Exit code file not found. Installation may have failed.\"\n        $exitCode = 1\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Write-Host \"Cleaning up...\"\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode\n\n"
  }
}