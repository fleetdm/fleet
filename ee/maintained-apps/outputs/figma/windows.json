{
  "versions": [
    {
      "version": "125.11.6",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name = 'Figma' AND publisher = 'Figma, Inc.';"
      },
      "installer_url": "https://desktop.figma.com/win/build/Figma-125.11.6.exe",
      "install_script_ref": "442d71b3",
      "uninstall_script_ref": "e33afd6b",
      "sha256": "cfb16dea2b8b7e2b1584f693227a7fd5acadd662600fa9d93d2a45eae056ca72",
      "default_categories": [
        "Productivity"
      ]
    }
  ],
  "refs": {
    "442d71b3": "$exeFilePath = \"${env:INSTALLER_PATH}\"\n\n$exitCode = 0\n\ntry {\n\n# Copy the installer to a public folder so that all users can access it\n$exeFilename = Split-Path $exeFilePath -leaf\nCopy-Item -Path $exeFilePath -Destination \"${env:PUBLIC}\" -Force\n$exeFilePath = \"${env:PUBLIC}\\$exeFilename\"\n\n# Task properties. The task will be started by the logged in user\n# Figma uses -s for silent installation (Squirrel installer)\n$action = New-ScheduledTaskAction -Execute \"$exeFilePath\" -Argument \"-s\"\n$trigger = New-ScheduledTaskTrigger -AtLogOn\n$userName = (Get-CimInstance Win32_Process -Filter 'name = \"explorer.exe\"' | Invoke-CimMethod -MethodName getowner).User\n$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n# Create a task object with the properties defined above\n$task = New-ScheduledTask -Action $action -Trigger $trigger `\n    -Settings $settings\n\n# Register the task\n$taskName = \"fleet-install-$exeFilename\"\nRegister-ScheduledTask \"$taskName\" -InputObject $task -User \"$userName\"\n\n# keep track of the start time to cancel if taking too long to start\n$startDate = Get-Date\n\n# Start the task now that it is ready\nStart-ScheduledTask -TaskName \"$taskName\" -TaskPath \"\\\"\n\n# Wait for the task to be running\n$state = (Get-ScheduledTask -TaskName \"$taskName\").State\nWrite-Host \"ScheduledTask is '$state'\"\n\nwhile ($state  -ne \"Running\") {\n    Write-Host \"ScheduledTask is '$state'. Waiting to run .exe...\"\n\n    $endDate = Get-Date\n    $elapsedTime = New-Timespan -Start $startDate -End $endDate\n    if ($elapsedTime.TotalSeconds -gt 120) {\n        Throw \"Timed-out waiting for scheduled task state.\"\n    }\n\n    Start-Sleep -Seconds 1\n    $state = (Get-ScheduledTask -TaskName \"$taskName\").State\n}\n\n# Wait for the task to be done\n$state = (Get-ScheduledTask -TaskName \"$taskName\").State\nwhile ($state  -eq \"Running\") {\n    Write-Host \"ScheduledTask is '$state'. Waiting for .exe to complete...\"\n\n    $endDate = Get-Date\n    $elapsedTime = New-Timespan -Start $startDate -End $endDate\n    if ($elapsedTime.TotalSeconds -gt 120) {\n        Throw \"Timed-out waiting for scheduled task state.\"\n    }\n\n    Start-Sleep -Seconds 10\n    $state = (Get-ScheduledTask -TaskName \"$taskName\").State\n}\n\n# Wait a moment for registry to update after installation\nStart-Sleep -Seconds 2\n\n# Remove task\nWrite-Host \"Removing ScheduledTask: $taskName.\"\nUnregister-ScheduledTask -TaskName \"$taskName\" -Confirm:$false\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Remove installer\n    Remove-Item -Path $exeFilePath -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode\n",
    "e33afd6b": "# Attempts to locate Figma's uninstaller from registry and execute it silently\n\n$displayName = \"Figma\"\n$publisher = \"Figma, Inc.\"\n\n$paths = @(\n  'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKCU:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall'\n)\n\n$uninstall = $null\nforeach ($p in $paths) {\n  $items = Get-ItemProperty \"$p\\*\" -ErrorAction SilentlyContinue | Where-Object {\n    $_.DisplayName -and ($_.DisplayName -eq $displayName -or $_.DisplayName -like \"$displayName*\") -and ($publisher -eq \"\" -or $_.Publisher -eq $publisher)\n  }\n  if ($items) { $uninstall = $items | Select-Object -First 1; break }\n}\n\nif (-not $uninstall -or -not $uninstall.UninstallString) {\n  Write-Host \"Uninstall entry not found\"\n  Exit 0\n}\n\n# Kill any running Figma processes before uninstalling\nStop-Process -Name \"Figma\" -Force -ErrorAction SilentlyContinue\n\n$uninstallString = $uninstall.UninstallString\n$exePath = \"\"\n$arguments = \"\"\n\n# Parse the uninstall string to extract executable path and existing arguments\n# Handles both quoted and unquoted paths\nif ($uninstallString -match '^\"([^\"]+)\"(.*)') {\n    $exePath = $matches[1]\n    $arguments = $matches[2].Trim()\n} elseif ($uninstallString -match '^([^\\s]+)(.*)') {\n    $exePath = $matches[1]\n    $arguments = $matches[2].Trim()\n} else {\n    Write-Host \"Error: Could not parse uninstall string: $uninstallString\"\n    Exit 1\n}\n\n# Build argument list array, preserving existing arguments and adding -s for silent\n$argumentList = @()\nif ($arguments -ne '') {\n    # Split existing arguments and add them\n    $argumentList += $arguments -split '\\s+'\n}\n# Add -s for silent uninstall if not already present\nif ($argumentList -notcontains \"-s\" -and $argumentList -notcontains \"--silent\") {\n    $argumentList += \"-s\"\n}\n\nWrite-Host \"Uninstall executable: $exePath\"\nWrite-Host \"Uninstall arguments: $($argumentList -join ' ')\"\n\ntry {\n    $processOptions = @{\n        FilePath = $exePath\n        ArgumentList = $argumentList\n        NoNewWindow = $true\n        PassThru = $true\n        Wait = $true\n    }\n    \n    $process = Start-Process @processOptions\n    $exitCode = $process.ExitCode\n    \n    Write-Host \"Uninstall exit code: $exitCode\"\n    Exit $exitCode\n} catch {\n    Write-Host \"Error running uninstaller: $_\"\n    Exit 1\n}\n\n"
  }
}
