{
  "versions": [
    {
      "version": "1.83.1.5",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name = 'Arc' AND publisher = 'The Browser Company of New York';"
      },
      "installer_url": "https://releases.arc.net/windows/prod/1.83.1.5/Arc.x64.msix",
      "install_script_ref": "58c2c9b3",
      "uninstall_script_ref": "2af7a71a",
      "sha256": "ebac26939238a5b97f61f4220fd1fe6f0decf90f3bbc6c489a8f1e93b25f6419",
      "default_categories": [
        "Browsers"
      ]
    }
  ],
  "refs": {
    "2af7a71a": "$softwareName = \"Arc\"\n$packageName = \"Arc\"\n$taskName = \"fleet-uninstall-$softwareName.msix\"\n$scriptPath = \"$env:PUBLIC\\uninstall-$softwareName.ps1\"\n$exitCodeFile = \"$env:PUBLIC\\uninstall-exitcode-$softwareName.txt\"\n\n$userScript = @\"\n`$packageName = \"$packageName\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\n\ntry {\n    Write-Host \"=== Arc Uninstallation Start ===\"\n\n    # Remove for current user\n    Write-Host \"Removing package for current user...\"\n    `$package = Get-AppxPackage -Name `$packageName -ErrorAction SilentlyContinue\n    if (`$package) {\n        Remove-AppxPackage -Package `$package.PackageFullName -ErrorAction Stop\n        Write-Host \"Removed for current user\"\n    } else {\n        Write-Host \"Package not found for current user\"\n    }\n\n    # Also remove provisioned package for all future users\n    Write-Host \"Removing provisioned package for all future users...\"\n    `$provisioned = Get-AppxProvisionedPackage -Online | Where-Object { `$_.DisplayName -eq `$packageName } | Select-Object -First 1\n    if (`$provisioned) {\n        Remove-AppxProvisionedPackage -Online -PackageName `$provisioned.PackageName -ErrorAction Stop\n        Write-Host \"Removed provisioned package\"\n    } else {\n        Write-Host \"Provisioned package not found\"\n    }\n\n    Write-Host \"=== Uninstallation Successful ===\"\n} catch {\n    Write-Host \"=== Uninstallation Failed ===\"\n    Write-Host \"Error: `$(`$_.Exception.Message)\"\n    `$exitCode = 1\n} finally {\n    Write-Host \"Exit Code: `$exitCode\"\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on (with timeout for headless environments)\n    $maxWaitTime = 60  # Maximum wait time in seconds\n    $startTime = Get-Date\n    $userName = $null\n    \n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            break\n        }\n        \n        $elapsed = (New-Timespan -Start $startTime).TotalSeconds\n        if ($elapsed -gt $maxWaitTime) {\n            # Timeout reached - likely headless environment\n            # Run uninstallation directly without scheduled task\n            Write-Host \"No interactive user detected after $maxWaitTime seconds. Running uninstallation directly (headless mode)...\"\n            \n            # Write the script to disk and execute it directly\n            Set-Content -Path $scriptPath -Value $userScript -Force\n            & powershell.exe -WindowStyle Hidden -ExecutionPolicy Bypass -File $scriptPath\n            \n            if (Test-Path $exitCodeFile) {\n                $exitCode = Get-Content $exitCodeFile\n            } else {\n                $exitCode = 1\n            }\n            \n            # Clean up\n            Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n            Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n            \n            Exit $exitCode\n        }\n        \n        Start-Sleep -Seconds 5\n    }\n\n    # Write the uninstall script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script (output goes to stdout for Fleet)\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\"\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode\n\n",
    "58c2c9b3": "$softwareName = \"Arc\"\n$msixPath = \"${env:INSTALLER_PATH}\"\n$taskName = \"fleet-install-$softwareName.msix\"\n$scriptPath = \"$env:PUBLIC\\install-$softwareName.ps1\"\n$exitCodeFile = \"$env:PUBLIC\\install-exitcode-$softwareName.txt\"\n\n$userScript = @\"\n`$msixPath = \"$msixPath\"\n`$exitCodeFile = \"$exitCodeFile\"\n`$exitCode = 0\n\ntry {\n    Write-Host \"=== Arc Installation Start ===\"\n    Write-Host \"MSIX Path: `$msixPath\"\n\n    # Provision for all future users\n    Write-Host \"[1/3] Provisioning for all future users...\"\n    Add-AppProvisionedPackage -Online -PackagePath `$msixPath -SkipLicense -ErrorAction Stop\n    Write-Host \"[1/3] Provisioning complete\"\n\n    # Also install for current user so osquery can detect it immediately\n    Write-Host \"[2/3] Installing for current user...\"\n    try {\n        Add-AppxPackage -Path `$msixPath -ErrorAction Stop | Out-Null\n        Write-Host \"[2/3] Installation complete\"\n    } catch {\n        Write-Host \"[2/3] User installation failed (may be headless environment), continuing...\"\n        # Don't fail the script if user install fails - provisioning is the important part\n    }\n\n    # Poll for package registration (up to 30 seconds)\n    Write-Host \"[3/3] Polling for registration (max 30s)...\"\n    `$maxAttempts = 30\n    `$attempt = 0\n    `$installed = `$null\n\n    while (`$attempt -lt `$maxAttempts) {\n        `$installed = Get-AppxPackage -Name \"Arc\" -ErrorAction SilentlyContinue\n        if (`$installed) {\n            Write-Host \"[3/3] Package registered after `$attempt seconds\"\n            break\n        }\n        Start-Sleep -Seconds 1\n        `$attempt++\n    }\n\n    # Check if package is provisioned (works even if user install failed)\n    `$provisioned = Get-AppxProvisionedPackage -Online | Where-Object { `$_.DisplayName -eq \"Arc\" } | Select-Object -First 1\n    if (-not `$installed -and -not `$provisioned) {\n        Write-Host \"[3/3] ERROR: Package not registered and not provisioned\"\n        `$exitCode = 1\n    } elseif (-not `$installed) {\n        # Package is provisioned but not installed for current user (likely headless environment)\n        Write-Host \"[3/3] Package is provisioned but not installed for current user\"\n        Write-Host \"=== Installation Successful (Provisioned) ===\"\n        Write-Host \"Package: `$(`$provisioned.DisplayName)\"\n        Write-Host \"Version: `$(`$provisioned.Version)\"\n    } else {\n        Write-Host \"=== Installation Successful ===\"\n        Write-Host \"Package: `$(`$installed.PackageFullName)\"\n        Write-Host \"Version: `$(`$installed.Version)\"\n    }\n    \n    # Give osquery time to detect the app in the programs table\n    Start-Sleep -Seconds 5\n} catch {\n    Write-Host \"=== Installation Failed ===\"\n    Write-Host \"Error: `$(`$_.Exception.Message)\"\n    `$exitCode = 1\n} finally {\n    Write-Host \"Exit Code: `$exitCode\"\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on (with timeout for headless environments)\n    $maxWaitTime = 60  # Maximum wait time in seconds\n    $startTime = Get-Date\n    $userName = $null\n    \n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            break\n        }\n        \n        $elapsed = (New-Timespan -Start $startTime).TotalSeconds\n        if ($elapsed -gt $maxWaitTime) {\n            # Timeout reached - likely headless environment\n            # Run installation directly without scheduled task\n            Write-Host \"No interactive user detected after $maxWaitTime seconds. Running installation directly (headless mode)...\"\n            \n            # Write the script to disk and execute it directly\n            Set-Content -Path $scriptPath -Value $userScript -Force\n            & powershell.exe -WindowStyle Hidden -ExecutionPolicy Bypass -File $scriptPath\n            \n            if (Test-Path $exitCodeFile) {\n                $exitCode = Get-Content $exitCodeFile\n            } else {\n                $exitCode = 1\n            }\n            \n            # Clean up\n            Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n            Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n            \n            Exit $exitCode\n        }\n        \n        Start-Sleep -Seconds 5\n    }\n\n    # Write the install script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script (output goes to stdout for Fleet)\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\"\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force | Out-Null\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n    } else {\n        $exitCode = 1\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode\n\n"
  }
}
