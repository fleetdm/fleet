{
  "versions": [
    {
      "version": "137.1.79.119",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name = 'Brave' AND publisher = 'Brave Software Inc';"
      },
      "installer_url": "https://github.com/brave/brave-browser/releases/download/v1.79.119/BraveBrowserStandaloneSilentSetup.exe",
      "install_script_ref": "9a0c2b15",
      "uninstall_script_ref": "30c77f69",
      "sha256": "643774c05c5cf10f1b2776dd2205e082ba098d0ea4b1795d399c670e63c91c8a",
      "default_categories": [
        "Browsers"
      ]
    }
  ],
  "refs": {
    "30c77f69": "$softwareName = \"Brave\"\n\n# Script to uninstall software as the current logged-in user.\n$userScript = @'\n\n# Define acceptable/expected exit codes\n$ExpectedExitCodes = @(0, 19)\n\n$softwareName = \"Brave\"\n\n# Using the exact software name here is recommended to avoid\n# uninstalling unintended software.\n$softwareNameLike = \"*$softwareName*\"\n\n# Some uninstallers require additional flags to run silently.\n# Each uninstaller might use a different argument (usually it's \"/S\" or \"/s\")\n$uninstallArgs = \"--force-uninstall\"\n\n$uninstallCommand = \"\"\n$exitCode = 0\n\ntry {\n\n$userKey = `\n 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*'\n[array]$uninstallKeys = Get-ChildItem `\n    -Path @($userKey) `\n    -ErrorAction SilentlyContinue |\n        ForEach-Object { Get-ItemProperty $_.PSPath }\n\n$foundUninstaller = $false\nforeach ($key in $uninstallKeys) {\n    # If needed, add -notlike to the comparison to exclude certain similar\n    # software\n    if ($key.DisplayName -like $softwareNameLike) {\n        $foundUninstaller = $true\n        # Get the uninstall command. Some uninstallers do not include\n        # 'QuietUninstallString' and require a flag to run silently.\n        $uninstallCommand = if ($key.QuietUninstallString) {\n            $key.QuietUninstallString\n        } else {\n            $key.UninstallString\n        }\n\n        # The uninstall command may contain command and args, like:\n        # \"C:\\Program Files\\Software\\uninstall.exe\" --uninstall --silent\n        # Split the command and args\n        $splitArgs = $uninstallCommand.Split('\"')\n        if ($splitArgs.Length -gt 1) {\n            if ($splitArgs.Length -eq 3) {\n                $uninstallArgs = \"$( $splitArgs[2] ) $uninstallArgs\".Trim()\n            } elseif ($splitArgs.Length -gt 3) {\n                Throw `\n                    \"Uninstall command contains multiple quoted strings. \" +\n                        \"Please update the uninstall script.`n\" +\n                        \"Uninstall command: $uninstallCommand\"\n            }\n            $uninstallCommand = $splitArgs[1]\n        }\n        Write-Host \"Uninstall command: $uninstallCommand\"\n        Write-Host \"Uninstall args: $uninstallArgs\"\n\n        $processOptions = @{\n            FilePath = $uninstallCommand\n            PassThru = $true\n            Wait = $true\n        }\n        if ($uninstallArgs -ne '') {\n            $processOptions.ArgumentList = \"$uninstallArgs\"\n        }\n\n        # Start the process and track the exit code\n        $process = Start-Process @processOptions\n        $exitCode = $process.ExitCode\n\n        # Prints the exit code\n        Write-Host \"Uninstall exit code: $exitCode\"\n        # Exit the loop once the software is found and uninstalled.\n        break\n    }\n}\n\nif (-not $foundUninstaller) {\n    Write-Host \"Uninstaller for '$softwareName' not found.\"\n    $exitCode = 1\n}\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n}\n\n# Treat acceptable exit codes as success\nif ($ExpectedExitCodes -contains $exitCode) {\n    Exit 0\n} else {\n    Exit $exitCode\n}\n'@\n\n$exitCode = 0\n\n# Create a script in a public folder so that it can be accessed by all users.\n$uninstallScriptPath = \"${env:PUBLIC}/uninstall-$softwareName.ps1\"\n$taskName = \"fleet-uninstall-$softwareName\"\ntry {\n    Set-Content -Path $uninstallScriptPath -Value $userScript -Force\n\n    # Task properties. The task will be started by the logged in user\n    $action = New-ScheduledTaskAction -Execute \"PowerShell.exe\" `\n        -Argument \"$uninstallScriptPath\"\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n    $userName = (Get-CimInstance Win32_Process -Filter 'name = \"explorer.exe\"' | Invoke-CimMethod -MethodName getowner).User\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    # Create a task object with the properties defined above\n    $task = New-ScheduledTask -Action $action -Trigger $trigger `\n        -Settings $settings\n\n    # Register the task\n    Register-ScheduledTask \"$taskName\" -InputObject $task -User \"$userName\"\n\n    # keep track of the start time to cancel if taking too long to start\n    $startDate = Get-Date\n\n    # Start the task now that it is ready\n    Start-ScheduledTask -TaskName \"$taskName\" -TaskPath \"\\\"\n\n    # Wait for the task to be running\n    $state = (Get-ScheduledTask -TaskName \"$taskName\").State\n    Write-Host \"ScheduledTask is '$state'\"\n\n    while ($state  -ne \"Running\") {\n        Write-Host \"ScheduledTask is '$state'. Waiting to uninstall...\"\n\n        $endDate = Get-Date\n        $elapsedTime = New-Timespan -Start $startDate -End $endDate\n        if ($elapsedTime.TotalSeconds -gt 120) {\n            Throw \"Timed-out waiting for scheduled task state.\"\n        }\n\n        Start-Sleep -Seconds 1\n        $state = (Get-ScheduledTask -TaskName \"$taskName\").State\n    }\n\n    # Wait for the task to be done\n    $state = (Get-ScheduledTask -TaskName \"$taskName\").State\n    while ($state  -eq \"Running\") {\n        Write-Host \"ScheduledTask is '$state'. Waiting for .exe to complete...\"\n\n        $endDate = Get-Date\n        $elapsedTime = New-Timespan -Start $startDate -End $endDate\n        if ($elapsedTime.TotalSeconds -gt 120) {\n            Throw \"Timed-out waiting for scheduled task state.\"\n        }\n\n        Start-Sleep -Seconds 10\n        $state = (Get-ScheduledTask -TaskName \"$taskName\").State\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Remove task\n    Write-Host \"Removing ScheduledTask: $taskName.\"\n    Unregister-ScheduledTask -TaskName \"$taskName\" -Confirm:$false\n\n    # Remove user script\n    Remove-Item -Path $uninstallScriptPath -Force\n}\n\nExit $exitCode",
    "9a0c2b15": "$exeFilePath = \"${env:INSTALLER_PATH}\"\n\n$exitCode = 0\n\ntry {\n\n# Copy the installer to a public folder so that all can access it\n# users\n$exeFilename = Split-Path $exeFilePath -leaf\nCopy-Item -Path $exeFilePath -Destination \"${env:PUBLIC}\" -Force\n$exeFilePath = \"${env:PUBLIC}\\$exeFilename\"\n\n# Task properties. The task will be started by the logged in user\n$action = New-ScheduledTaskAction -Execute \"$exeFilePath\"\n$trigger = New-ScheduledTaskTrigger -AtLogOn\n$userName = (Get-CimInstance Win32_Process -Filter 'name = \"explorer.exe\"' | Invoke-CimMethod -MethodName getowner).User\n$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n# Create a task object with the properties defined above\n$task = New-ScheduledTask -Action $action -Trigger $trigger `\n    -Settings $settings\n\n# Register the task\n$taskName = \"fleet-install-$exeFilename\"\nRegister-ScheduledTask \"$taskName\" -InputObject $task -User \"$userName\"\n\n# keep track of the start time to cancel if taking too long to start\n$startDate = Get-Date\n\n# Start the task now that it is ready\nStart-ScheduledTask -TaskName \"$taskName\" -TaskPath \"\\\"\n\n# Wait for the task to be running\n$state = (Get-ScheduledTask -TaskName \"$taskName\").State\nWrite-Host \"ScheduledTask is '$state'\"\n\nwhile ($state  -ne \"Running\") {\n    Write-Host \"ScheduledTask is '$state'. Waiting to run .exe...\"\n\n    $endDate = Get-Date\n    $elapsedTime = New-Timespan -Start $startDate -End $endDate\n    if ($elapsedTime.TotalSeconds -gt 120) {\n        Throw \"Timed-out waiting for scheduled task state.\"\n    }\n\n    Start-Sleep -Seconds 1\n    $state = (Get-ScheduledTask -TaskName \"$taskName\").State\n}\n\n# Wait for the task to be done\n$state = (Get-ScheduledTask -TaskName \"$taskName\").State\nwhile ($state  -eq \"Running\") {\n    Write-Host \"ScheduledTask is '$state'. Waiting for .exe to complete...\"\n\n    $endDate = Get-Date\n    $elapsedTime = New-Timespan -Start $startDate -End $endDate\n    if ($elapsedTime.TotalSeconds -gt 120) {\n        Throw \"Timed-out waiting for scheduled task state.\"\n    }\n\n    Start-Sleep -Seconds 10\n    $state = (Get-ScheduledTask -TaskName \"$taskName\").State\n}\n\n# Remove task\nWrite-Host \"Removing ScheduledTask: $taskName.\"\nUnregister-ScheduledTask -TaskName \"$taskName\" -Confirm:$false\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Remove installer\n    Remove-Item -Path $exeFilePath -Force\n}\n\nExit $exitCode"
  }
}
