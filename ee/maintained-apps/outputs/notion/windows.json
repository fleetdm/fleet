{
  "versions": [
    {
      "version": "6.1.0",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name = 'Notion 6.1.0' AND publisher = 'Notion Labs, Inc';"
      },
      "installer_url": "https://desktop-release.notion-static.com/Notion%20Setup%206.1.0.exe",
      "install_script_ref": "0803ad8c",
      "uninstall_script_ref": "a8fdd9b7",
      "sha256": "8d50c7a3f7208a6dcf2038a19a664a278c82b752ead7586a796fc10812f34245",
      "default_categories": [
        "Productivity"
      ]
    }
  ],
  "refs": {
    "0803ad8c": "# Learn more about .exe install scripts:\n# http://fleetdm.com/learn-more-about/exe-install-scripts\n\n$exeFilePath = \"${env:INSTALLER_PATH}\"\n\ntry {\n\n# Add argument to install silently\n# NSIS installers require /S flag for silent installation\n$processOptions = @{\n  FilePath = \"$exeFilePath\"\n  ArgumentList = \"/S\"\n  PassThru = $true\n  Wait = $true\n}\n    \n# Start process and track exit code\n$process = Start-Process @processOptions\n$exitCode = $process.ExitCode\n\n# Prints the exit code\nWrite-Host \"Install exit code: $exitCode\"\nExit $exitCode\n\n} catch {\n  Write-Host \"Error: $_\"\n  Exit 1\n}",
    "a8fdd9b7": "$softwareName = \"notion\"\n$productKey = \"661f0cc6-343a-59cb-a5e8-8f6324cc6998\"\n$taskName = \"fleet-uninstall-$softwareName\"\n$scriptPath = \"$env:PUBLIC\\uninstall-$softwareName.ps1\"\n$logFile = \"$env:PUBLIC\\uninstall-output-$softwareName.txt\"\n$exitCodeFile = \"$env:PUBLIC\\uninstall-exitcode-$softwareName.txt\"\n\n# Embedded uninstall script\n$userScript = @\"\n`$userKey = \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$productKey\"\n`$exitCode = 0\n`$logFile = \"$logFile\"\n`$exitCodeFile = \"$exitCodeFile\"\n\nStart-Transcript -Path \"$logFile\" -Append\n\ntry {\n    `$key = Get-ItemProperty -Path `$userKey -ErrorAction Stop\n\n    `$uninstallCommand = if (`$key.QuietUninstallString) {\n        `$key.QuietUninstallString\n    } else {\n        `$key.UninstallString\n    }\n\n    `$splitArgs = `$uninstallCommand.Split('\"')\n    if (`$splitArgs.Length -gt 1) {\n        if (`$splitArgs.Length -eq 3) {\n            `$uninstallArgs = `$splitArgs[2].Trim()\n        } elseif (`$splitArgs.Length -gt 3) {\n            Throw \"Uninstall command contains multiple quoted strings. Please update the uninstall script.`nUninstall command: `$uninstallCommand\"\n        }\n        `$uninstallCommand = `$splitArgs[1]\n    }\n\n    # NSIS installers require /S flag for silent uninstall\n    # Append /S if not already present in the uninstall args\n    if (`$uninstallArgs) {\n        if (`$uninstallArgs -notmatch '\\b/S\\b') {\n            `$uninstallArgs = \"`$uninstallArgs /S\".Trim()\n        }\n    } else {\n        `$uninstallArgs = \"/S\"\n    }\n\n    Write-Host \"Uninstall command: `$uninstallCommand\"\n    Write-Host \"Uninstall args: `$uninstallArgs\"\n\n    `$processOptions = @{\n        FilePath = `$uninstallCommand\n        PassThru = `$true\n        Wait     = `$true\n    }\n\n    if (`$uninstallArgs -ne '') {\n        `$processOptions.ArgumentList = \"`$uninstallArgs\"\n    }\n\n    `$process = Start-Process @processOptions\n    `$exitCode = `$process.ExitCode\n    Write-Host \"Uninstall exit code: `$exitCode\"\n}\ncatch {\n    Write-Host \"Error: `$_.Exception.Message\"\n    `$exitCode = 1\n}\nfinally {\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\n\nStop-Transcript\n\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Wait for an interactive user to be logged on\n    while ($true) {\n        $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n        if ($userName -and $userName -like \"*\\*\") {\n            Write-Output \"Interactive user detected: $userName\"\n            break\n        } else {\n            Start-Sleep -Seconds 5\n        }\n    }\n\n    # Write the uninstall script to disk\n    Set-Content -Path $scriptPath -Value $userScript -Force\n\n    # Build task action: run script, redirect stdout/stderr to log file\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptPath`\" *> `\"$logFile`\" 2>&1\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Show task output\n    if (Test-Path $logFile) {\n        Write-Host \"`n--- Scheduled Task Output ---\"\n        Get-Content $logFile | Write-Host\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n        Write-Host \"`nScheduled task exit code: $exitCode\"\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Write-Host \"Cleaning up...\"\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode\n"
  }
}
