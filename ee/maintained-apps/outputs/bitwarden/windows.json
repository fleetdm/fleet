{
  "versions": [
    {
      "version": "2025.11.2",
      "queries": {
        "exists": "SELECT 1 FROM programs WHERE name = 'Bitwarden' AND publisher = 'Bitwarden Inc.';"
      },
      "installer_url": "https://github.com/bitwarden/clients/releases/download/desktop-v2025.11.2/Bitwarden-Installer-2025.11.2.exe",
      "install_script_ref": "b514ead2",
      "uninstall_script_ref": "992f7088",
      "sha256": "6870d6e1a938748017417f3cfcb8ea60e6d4b0b202f20d53fbd9aa697f6dd4d4",
      "default_categories": [
        "Productivity"
      ]
    }
  ],
  "refs": {
    "992f7088": "# Attempts to locate Bitwarden's uninstaller from registry and execute it silently\n\n$displayName = \"Bitwarden\"\n$publisher = \"8bit Solutions LLC\"\n\n# Some uninstallers require a flag to run silently.\n# NSIS installers typically use \"/S\" for silent uninstall\n$uninstallArgs = \"/S\"\n\n$paths = @(\n  'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',\n  'HKCU:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall'\n)\n\n$exitCode = 0\n\nWrite-Host \"Starting Bitwarden uninstall script\"\nWrite-Host \"Searching for DisplayName: $displayName\"\nWrite-Host \"Searching for Publisher: $publisher\"\n\ntry {\n    # Kill any running Bitwarden processes before uninstalling\n    Stop-Process -Name \"Bitwarden\" -Force -ErrorAction SilentlyContinue\n\n    [array]$uninstallKeys = Get-ChildItem `\n        -Path $paths `\n        -ErrorAction SilentlyContinue |\n            ForEach-Object { Get-ItemProperty $_.PSPath }\n\n    Write-Host \"Found $($uninstallKeys.Count) total uninstall entries in registry\"\n    \n    # Debug: List all Bitwarden-like entries\n    $bitwardenLike = $uninstallKeys | Where-Object { $_.DisplayName -and $_.DisplayName -like \"*Bitwarden*\" }\n    Write-Host \"Found $($bitwardenLike.Count) entries matching '*Bitwarden*'\"\n    foreach ($entry in $bitwardenLike) {\n        Write-Host \"  - DisplayName: $($entry.DisplayName), Publisher: $($entry.Publisher)\"\n    }\n\n    $foundUninstaller = $false\n    foreach ($key in $uninstallKeys) {\n        # More lenient matching - check DisplayName first, then publisher\n        $nameMatches = $key.DisplayName -and ($key.DisplayName -eq $displayName -or $key.DisplayName -like \"$displayName*\")\n        $publisherMatches = $publisher -eq \"\" -or $key.Publisher -eq $publisher -or $key.Publisher -like \"*$publisher*\"\n        \n        if ($nameMatches) {\n            Write-Host \"Checking entry: DisplayName='$($key.DisplayName)', Publisher='$($key.Publisher)'\"\n            if ($publisherMatches -or $publisher -eq \"\") {\n                $foundUninstaller = $true\n                $registryKeyPath = $key.PSPath\n                Write-Host \"Found Bitwarden installation: $($key.DisplayName)\"\n                Write-Host \"Registry key: $registryKeyPath\"\n                Write-Host \"UninstallString: $($key.UninstallString)\"\n                Write-Host \"QuietUninstallString: $($key.QuietUninstallString)\"\n            \n            # Prefer QuietUninstallString if available - it's designed for silent uninstalls\n            # If QuietUninstallString exists, use it directly without modification\n            if ($key.QuietUninstallString) {\n                Write-Host \"Using QuietUninstallString for silent uninstall\"\n                $uninstallCommand = $key.QuietUninstallString\n                \n                # Execute QuietUninstallString directly via cmd.exe\n                # This is more reliable than parsing and reconstructing\n                Write-Host \"Executing: cmd.exe /c `\"$uninstallCommand`\"\"\n                $process = Start-Process -FilePath \"cmd.exe\" -ArgumentList \"/c\", \"`\"$uninstallCommand`\"\" -PassThru -Wait -NoNewWindow\n                $exitCode = $process.ExitCode\n                Write-Host \"Uninstall exit code: $exitCode\"\n            } else {\n                # Fall back to UninstallString and add /S for silent\n                Write-Host \"Using UninstallString with /S switch\"\n                $uninstallCommand = $key.UninstallString\n                \n                # Parse the uninstall command to separate executable from arguments\n                $splitArgs = $uninstallCommand.Split('\"')\n                if ($splitArgs.Length -gt 1) {\n                    if ($splitArgs.Length -eq 3) {\n                        $existingArgs = $splitArgs[2].Trim()\n                        $uninstallArgs = if ($existingArgs) { \"$existingArgs /S\" } else { \"/S\" }\n                    } elseif ($splitArgs.Length -gt 3) {\n                        Throw `\n                            \"Uninstall command contains multiple quoted strings. \" +\n                                \"Please update the uninstall script.`n\" +\n                                \"Uninstall command: $uninstallCommand\"\n                    }\n                    $uninstallCommand = $splitArgs[1]\n                }\n                Write-Host \"Uninstall executable: $uninstallCommand\"\n                Write-Host \"Uninstall args: $uninstallArgs\"\n\n                $processOptions = @{\n                    FilePath = $uninstallCommand\n                    PassThru = $true\n                    Wait = $true\n                }\n                if ($uninstallArgs -ne '') {\n                    $processOptions.ArgumentList = \"$uninstallArgs\"\n                }\n\n                # Start process and track exit code\n                $process = Start-Process @processOptions\n                $exitCode = $process.ExitCode\n                Write-Host \"Uninstall exit code: $exitCode\"\n            }\n            \n            # Wait for registry to update after uninstall completes\n            # NSIS uninstallers may take a moment to clean up registry entries\n            if ($exitCode -eq 0) {\n                Write-Host \"Waiting for registry cleanup...\"\n                Start-Sleep -Seconds 5\n                \n                # Verify uninstall worked by checking registry again\n                $stillInstalled = $false\n                [array]$verifyKeys = Get-ChildItem `\n                    -Path $paths `\n                    -ErrorAction SilentlyContinue |\n                        ForEach-Object { Get-ItemProperty $_.PSPath }\n                \n                # Check if Bitwarden is still in registry\n                $stillInstalled = $false\n                $registryKeyToRemove = $null\n                \n                # Use the stored registry key path if available, otherwise search again\n                if ($registryKeyPath -and (Test-Path $registryKeyPath -ErrorAction SilentlyContinue)) {\n                    $stillInstalled = $true\n                    $registryKeyToRemove = $registryKeyPath\n                    Write-Host \"WARNING: Bitwarden registry entry still exists at: $registryKeyToRemove\"\n                } else {\n                    # Fallback: search again\n                    foreach ($verifyKey in $verifyKeys) {\n                        if ($verifyKey.DisplayName -and ($verifyKey.DisplayName -eq $displayName -or $verifyKey.DisplayName -like \"$displayName*\") -and ($publisher -eq \"\" -or $verifyKey.Publisher -eq $publisher -or $verifyKey.Publisher -like \"*$publisher*\")) {\n                            $stillInstalled = $true\n                            $registryKeyToRemove = $verifyKey.PSPath\n                            Write-Host \"WARNING: Bitwarden still found in registry after uninstall: $($verifyKey.DisplayName)\"\n                            break\n                        }\n                    }\n                }\n                \n                if ($stillInstalled -and $registryKeyToRemove) {\n                    Write-Host \"Attempting to manually remove registry entry: $registryKeyToRemove\"\n                    try {\n                        Remove-Item -Path $registryKeyToRemove -Force -Recurse -ErrorAction Stop\n                        Write-Host \"Successfully removed registry entry manually\"\n                        Start-Sleep -Seconds 2\n                        \n                        # Verify removal\n                        $finalCheck = Get-ItemProperty $registryKeyToRemove -ErrorAction SilentlyContinue\n                        if (-not $finalCheck) {\n                            Write-Host \"Verified: Registry entry successfully removed\"\n                        } else {\n                            Write-Host \"WARNING: Registry entry still exists after manual removal attempt\"\n                        }\n                    } catch {\n                        Write-Host \"Failed to manually remove registry entry: $_\"\n                    }\n                } elseif (-not $stillInstalled) {\n                    Write-Host \"Verified: Bitwarden successfully removed from registry\"\n                }\n            }\n            \n            # Exit the loop once the software is found and uninstalled.\n            break\n            } else {\n                Write-Host \"  Publisher mismatch: expected '$publisher', found '$($key.Publisher)'\"\n            }\n        }\n    }\n\n    if (-not $foundUninstaller) {\n        Write-Host \"ERROR: Uninstaller for '$displayName' not found in registry.\"\n        Write-Host \"Searched paths:\"\n        foreach ($path in $paths) {\n            Write-Host \"  - $path\"\n        }\n        # Change exit code to 0 if you don't want to fail if uninstaller is not\n        # found. This could happen if program was already uninstalled.\n        $exitCode = 0\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n}\n\nExit $exitCode\n\n",
    "b514ead2": "# Learn more about .exe install scripts:\n# http://fleetdm.com/learn-more-about/exe-install-scripts\n\n$exeFilePath = \"${env:INSTALLER_PATH}\"\n\ntry {\n\n# Add arguments to install silently\n# Bitwarden uses NSIS installer with /S for silent and /allusers for machine scope\n$processOptions = @{\n  FilePath = \"$exeFilePath\"\n  ArgumentList = \"/S /allusers\"\n  PassThru = $true\n  Wait = $true\n}\n    \n# Start process and track exit code\n$process = Start-Process @processOptions\n$exitCode = $process.ExitCode\n\n# Prints the exit code\nWrite-Host \"Install exit code: $exitCode\"\nExit $exitCode\n\n} catch {\n  Write-Host \"Error: $_\"\n  Exit 1\n}\n\n"
  }
}
