# Vulnerability Management Development Guide

This guide provides instructions for developing Vulnerability Management functionality in Fleet.

## Introduction

Vulnerability Management in Fleet identifies and manages software vulnerabilities in the device fleet. This guide covers the development and implementation of Vulnerability Management features.

## Prerequisites

Before you begin developing Vulnerability Management functionality, you should have:

- A development environment set up according to the [Building Fleet](../../getting-started/building-fleet.md) guide
- Basic understanding of software vulnerabilities and CVEs
- Familiarity with Fleet's architecture
- Understanding of vulnerability databases and scoring systems

## Vulnerability Management Architecture

Vulnerability Management in Fleet follows a specific flow:

1. Fleet server retrieves software inventory from the database
2. Fleet server compares software versions with vulnerability databases
3. Fleet server identifies vulnerable software and affected devices
4. Fleet server provides API endpoints for retrieving vulnerability information
5. Fleet UI displays vulnerability information in tables and dashboards

## Implementation

### Database Schema

Vulnerability information is stored in the Fleet database:

```sql
CREATE TABLE vulnerabilities (
  id INT AUTO_INCREMENT PRIMARY KEY,
  cve_id VARCHAR(255) NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  published_at TIMESTAMP,
  cvss_score FLOAT,
  cvss_vector VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY (cve_id)
);

CREATE TABLE software_vulnerabilities (
  id INT AUTO_INCREMENT PRIMARY KEY,
  software_id INT NOT NULL,
  vulnerability_id INT NOT NULL,
  fixed_in_version VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (software_id) REFERENCES software(id),
  FOREIGN KEY (vulnerability_id) REFERENCES vulnerabilities(id),
  UNIQUE KEY (software_id, vulnerability_id)
);

CREATE TABLE host_vulnerabilities (
  id INT AUTO_INCREMENT PRIMARY KEY,
  host_id INT NOT NULL,
  vulnerability_id INT NOT NULL,
  software_id INT NOT NULL,
  status VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (host_id) REFERENCES hosts(id),
  FOREIGN KEY (vulnerability_id) REFERENCES vulnerabilities(id),
  FOREIGN KEY (software_id) REFERENCES software(id),
  UNIQUE KEY (host_id, vulnerability_id, software_id)
);
```

### Vulnerability Data Sources

Implement vulnerability data source integration:

```go
type VulnerabilityDataSource interface {
    GetVulnerabilities() ([]Vulnerability, error)
    GetSoftwareVulnerabilities() ([]SoftwareVulnerability, error)
}

type NVDDataSource struct {
    APIURL     string
    APIKey     string
    LastUpdate time.Time
}

func (ds *NVDDataSource) GetVulnerabilities() ([]Vulnerability, error) {
    // Calculate the time range for the API request
    startDate := ds.LastUpdate
    endDate := time.Now()
    
    // Create the API request URL
    url := fmt.Sprintf(
        "%s/cves/2.0?pubStartDate=%s&pubEndDate=%s&apiKey=%s",
        ds.APIURL,
        startDate.Format(time.RFC3339),
        endDate.Format(time.RFC3339),
        ds.APIKey,
    )
    
    // Send the request
    resp, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    // Parse the response
    var nvdResp struct {
        Vulnerabilities []struct {
            CVE struct {
                ID          string `json:"id"`
                Published   string `json:"published"`
                Descriptions []struct {
                    Lang  string `json:"lang"`
                    Value string `json:"value"`
                } `json:"descriptions"`
                Metrics struct {
                    CVSSMetricV31 []struct {
                        CVSSV31 struct {
                            BaseScore    float64 `json:"baseScore"`
                            VectorString string  `json:"vectorString"`
                        } `json:"cvssData"`
                    } `json:"cvssMetricV31"`
                } `json:"metrics"`
            } `json:"cve"`
        } `json:"vulnerabilities"`
    }
    
    if err := json.NewDecoder(resp.Body).Decode(&nvdResp); err != nil {
        return nil, err
    }
    
    // Convert to our internal format
    vulnerabilities := []Vulnerability{}
    for _, nvdVuln := range nvdResp.Vulnerabilities {
        // Get the English description
        description := ""
        for _, desc := range nvdVuln.CVE.Descriptions {
            if desc.Lang == "en" {
                description = desc.Value
                break
            }
        }
        
        // Get the CVSS score and vector
        cvssScore := 0.0
        cvssVector := ""
        if len(nvdVuln.CVE.Metrics.CVSSMetricV31) > 0 {
            cvssScore = nvdVuln.CVE.Metrics.CVSSMetricV31[0].CVSSV31.BaseScore
            cvssVector = nvdVuln.CVE.Metrics.CVSSMetricV31[0].CVSSV31.VectorString
        }
        
        // Parse the published date
        publishedAt, err := time.Parse(time.RFC3339, nvdVuln.CVE.Published)
        if err != nil {
            return nil, err
        }
        
        // Create the vulnerability
        vulnerability := Vulnerability{
            CVEID:       nvdVuln.CVE.ID,
            Title:       nvdVuln.CVE.ID, // NVD doesn't provide a title, so use the ID
            Description: description,
            PublishedAt: publishedAt,
            CVSSScore:   cvssScore,
            CVSSVector:  cvssVector,
        }
        
        vulnerabilities = append(vulnerabilities, vulnerability)
    }
    
    // Update the last update time
    ds.LastUpdate = endDate
    
    return vulnerabilities, nil
}

func (ds *NVDDataSource) GetSoftwareVulnerabilities() ([]SoftwareVulnerability, error) {
    // This is a simplified implementation
    // In a real implementation, you would need to parse CPE data from NVD
    // and match it to your software inventory
    
    // For now, return an empty slice
    return []SoftwareVulnerability{}, nil
}
```

### Vulnerability Processing

Implement vulnerability processing:

```go
func ProcessVulnerabilities(db *sql.DB, vulnerabilities []Vulnerability) error {
    // Start a transaction
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // Process each vulnerability
    for _, vulnerability := range vulnerabilities {
        // Check if the vulnerability already exists
        var id int
        err := tx.QueryRow(
            "SELECT id FROM vulnerabilities WHERE cve_id = ?",
            vulnerability.CVEID,
        ).Scan(&id)
        
        if err == sql.ErrNoRows {
            // Insert the vulnerability
            result, err := tx.Exec(
                `INSERT INTO vulnerabilities (
                    cve_id, title, description, published_at, cvss_score, cvss_vector
                ) VALUES (?, ?, ?, ?, ?, ?)`,
                vulnerability.CVEID,
                vulnerability.Title,
                vulnerability.Description,
                vulnerability.PublishedAt,
                vulnerability.CVSSScore,
                vulnerability.CVSSVector,
            )
            if err != nil {
                return err
            }
            
            // Get the vulnerability ID
            id64, err := result.LastInsertId()
            if err != nil {
                return err
            }
            id = int(id64)
        } else if err != nil {
            return err
        } else {
            // Update the vulnerability
            _, err := tx.Exec(
                `UPDATE vulnerabilities SET
                    title = ?,
                    description = ?,
                    published_at = ?,
                    cvss_score = ?,
                    cvss_vector = ?,
                    updated_at = NOW()
                WHERE id = ?`,
                vulnerability.Title,
                vulnerability.Description,
                vulnerability.PublishedAt,
                vulnerability.CVSSScore,
                vulnerability.CVSSVector,
                id,
            )
            if err != nil {
                return err
            }
        }
    }
    
    // Commit the transaction
    err = tx.Commit()
    if err != nil {
        return err
    }
    
    return nil
}
```

### Software Vulnerability Processing

Implement software vulnerability processing:

```go
func ProcessSoftwareVulnerabilities(db *sql.DB, softwareVulnerabilities []SoftwareVulnerability) error {
    // Start a transaction
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // Process each software vulnerability
    for _, softwareVuln := range softwareVulnerabilities {
        // Get the software ID
        var softwareID int
        err := tx.QueryRow(
            "SELECT id FROM software WHERE name = ? AND version = ?",
            softwareVuln.SoftwareName,
            softwareVuln.SoftwareVersion,
        ).Scan(&softwareID)
        if err == sql.ErrNoRows {
            // Software not found, skip
            continue
        } else if err != nil {
            return err
        }
        
        // Get the vulnerability ID
        var vulnerabilityID int
        err = tx.QueryRow(
            "SELECT id FROM vulnerabilities WHERE cve_id = ?",
            softwareVuln.CVEID,
        ).Scan(&vulnerabilityID)
        if err == sql.ErrNoRows {
            // Vulnerability not found, skip
            continue
        } else if err != nil {
            return err
        }
        
        // Check if the software vulnerability already exists
        var id int
        err = tx.QueryRow(
            "SELECT id FROM software_vulnerabilities WHERE software_id = ? AND vulnerability_id = ?",
            softwareID,
            vulnerabilityID,
        ).Scan(&id)
        
        if err == sql.ErrNoRows {
            // Insert the software vulnerability
            _, err := tx.Exec(
                `INSERT INTO software_vulnerabilities (
                    software_id, vulnerability_id, fixed_in_version
                ) VALUES (?, ?, ?)`,
                softwareID,
                vulnerabilityID,
                softwareVuln.FixedInVersion,
            )
            if err != nil {
                return err
            }
        } else if err != nil {
            return err
        } else {
            // Update the software vulnerability
            _, err := tx.Exec(
                `UPDATE software_vulnerabilities SET
                    fixed_in_version = ?,
                    updated_at = NOW()
                WHERE id = ?`,
                softwareVuln.FixedInVersion,
                id,
            )
            if err != nil {
                return err
            }
        }
    }
    
    // Commit the transaction
    err = tx.Commit()
    if err != nil {
        return err
    }
    
    return nil
}
```

### Host Vulnerability Identification

Implement host vulnerability identification:

```go
func IdentifyHostVulnerabilities(db *sql.DB) error {
    // Start a transaction
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // Get all hosts
    hostRows, err := tx.Query("SELECT id FROM hosts")
    if err != nil {
        return err
    }
    defer hostRows.Close()
    
    // Process each host
    for hostRows.Next() {
        var hostID int
        err := hostRows.Scan(&hostID)
        if err != nil {
            return err
        }
        
        // Get the software for this host
        softwareRows, err := tx.Query(`
            SELECT s.id, s.name, s.version
            FROM software s
            JOIN host_software hs ON s.id = hs.software_id
            WHERE hs.host_id = ?
        `, hostID)
        if err != nil {
            return err
        }
        defer softwareRows.Close()
        
        // Process each software
        for softwareRows.Next() {
            var softwareID int
            var name, version string
            err := softwareRows.Scan(&softwareID, &name, &version)
            if err != nil {
                return err
            }
            
            // Get vulnerabilities for this software
            vulnRows, err := tx.Query(`
                SELECT v.id
                FROM vulnerabilities v
                JOIN software_vulnerabilities sv ON v.id = sv.vulnerability_id
                WHERE sv.software_id = ?
            `, softwareID)
            if err != nil {
                return err
            }
            defer vulnRows.Close()
            
            // Process each vulnerability
            for vulnRows.Next() {
                var vulnerabilityID int
                err := vulnRows.Scan(&vulnerabilityID)
                if err != nil {
                    return err
                }
                
                // Check if the host vulnerability already exists
                var id int
                err = tx.QueryRow(
                    `SELECT id FROM host_vulnerabilities
                     WHERE host_id = ? AND vulnerability_id = ? AND software_id = ?`,
                    hostID,
                    vulnerabilityID,
                    softwareID,
                ).Scan(&id)
                
                if err == sql.ErrNoRows {
                    // Insert the host vulnerability
                    _, err := tx.Exec(
                        `INSERT INTO host_vulnerabilities (
                            host_id, vulnerability_id, software_id, status
                        ) VALUES (?, ?, ?, ?)`,
                        hostID,
                        vulnerabilityID,
                        softwareID,
                        "open",
                    )
                    if err != nil {
                        return err
                    }
                } else if err != nil {
                    return err
                }
            }
        }
    }
    
    // Commit the transaction
    err = tx.Commit()
    if err != nil {
        return err
    }
    
    return nil
}
```

## API Endpoints

Implement API endpoints for vulnerability management:

### Get Vulnerabilities

```go
func GetVulnerabilitiesHandler(w http.ResponseWriter, r *http.Request) {
    // Get query parameters
    query := r.URL.Query().Get("q")
    limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
    offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))
    
    if limit == 0 {
        limit = 100
    }
    
    // Build the SQL query
    sqlQuery := `
        SELECT
            v.id,
            v.cve_id,
            v.title,
            v.description,
            v.published_at,
            v.cvss_score,
            v.cvss_vector,
            COUNT(DISTINCT hv.host_id) AS affected_hosts_count
        FROM vulnerabilities v
        LEFT JOIN host_vulnerabilities hv ON v.id = hv.vulnerability_id
    `
    
    // Add search condition if provided
    args := []interface{}{}
    if query != "" {
        sqlQuery += " WHERE v.cve_id LIKE ? OR v.title LIKE ? OR v.description LIKE ?"
        searchTerm := "%" + query + "%"
        args = append(args, searchTerm, searchTerm, searchTerm)
    }
    
    // Add group by and order by
    sqlQuery += " GROUP BY v.id ORDER BY v.cvss_score DESC, v.published_at DESC"
    
    // Add limit and offset
    sqlQuery += " LIMIT ? OFFSET ?"
    args = append(args, limit, offset)
    
    // Execute the query
    rows, err := db.Query(sqlQuery, args...)
    if err != nil {
        http.Error(w, fmt.Sprintf("Error getting vulnerabilities: %v", err), http.StatusInternalServerError)
        return
    }
    defer rows.Close()
    
    // Process the results
    vulnerabilities := []map[string]interface{}{}
    for rows.Next() {
        var id int
        var cveID, title, description string
        var publishedAt time.Time
        var cvssScore float64
        var cvssVector string
        var affectedHostsCount int
        
        err := rows.Scan(
            &id,
            &cveID,
            &title,
            &description,
            &publishedAt,
            &cvssScore,
            &cvssVector,
            &affectedHostsCount,
        )
        if err != nil {
            http.Error(w, fmt.Sprintf("Error scanning vulnerability: %v", err), http.StatusInternalServerError)
            return
        }
        
        vulnerability := map[string]interface{}{
            "id": id,
            "cve_id": cveID,
            "title": title,
            "description": description,
            "published_at": publishedAt.Unix(),
            "cvss_score": cvssScore,
            "cvss_vector": cvssVector,
            "affected_hosts_count": affectedHostsCount,
        }
        
        vulnerabilities = append(vulnerabilities, vulnerability)
    }
    
    // Return the vulnerabilities
    json.NewEncoder(w).Encode(vulnerabilities)
}
```

### Get Host Vulnerabilities

```go
func GetHostVulnerabilitiesHandler(w http.ResponseWriter, r *http.Request) {
    // Get the host ID from the URL
    vars := mux.Vars(r)
    hostID, err := strconv.Atoi(vars["host_id"])
    if err != nil {
        http.Error(w, "Invalid host ID", http.StatusBadRequest)
        return
    }
    
    // Get query parameters
    status := r.URL.Query().Get("status")
    
    // Build the SQL query
    sqlQuery := `
        SELECT
            hv.id,
            v.cve_id,
            v.title,
            v.description,
            v.published_at,
            v.cvss_score,
            v.cvss_vector,
            s.name AS software_name,
            s.version AS software_version,
            sv.fixed_in_version,
            hv.status
        FROM host_vulnerabilities hv
        JOIN vulnerabilities v ON hv.vulnerability_id = v.id
        JOIN software s ON hv.software_id = s.id
        JOIN software_vulnerabilities sv ON hv.vulnerability_id = sv.vulnerability_id AND hv.software_id = sv.software_id
        WHERE hv.host_id = ?
    `
    
    // Add status condition if provided
    args := []interface{}{hostID}
    if status != "" {
        sqlQuery += " AND hv.status = ?"
        args = append(args, status)
    }
    
    // Add order by
    sqlQuery += " ORDER BY v.cvss_score DESC, v.published_at DESC"
    
    // Execute the query
    rows, err := db.Query(sqlQuery, args...)
    if err != nil {
        http.Error(w, fmt.Sprintf("Error getting host vulnerabilities: %v", err), http.StatusInternalServerError)
        return
    }
    defer rows.Close()
    
    // Process the results
    vulnerabilities := []map[string]interface{}{}
    for rows.Next() {
        var id int
        var cveID, title, description string
        var publishedAt time.Time
        var cvssScore float64
        var cvssVector, softwareName, softwareVersion, fixedInVersion, status string
        
        err := rows.Scan(
            &id,
            &cveID,
            &title,
            &description,
            &publishedAt,
            &cvssScore,
            &cvssVector,
            &softwareName,
            &softwareVersion,
            &fixedInVersion,
            &status,
        )
        if err != nil {
            http.Error(w, fmt.Sprintf("Error scanning vulnerability: %v", err), http.StatusInternalServerError)
            return
        }
        
        vulnerability := map[string]interface{}{
            "id": id,
            "cve_id": cveID,
            "title": title,
            "description": description,
            "published_at": publishedAt.Unix(),
            "cvss_score": cvssScore,
            "cvss_vector": cvssVector,
            "software_name": softwareName,
            "software_version": softwareVersion,
            "fixed_in_version": fixedInVersion,
            "status": status,
        }
        
        vulnerabilities = append(vulnerabilities, vulnerability)
    }
    
    // Return the vulnerabilities
    json.NewEncoder(w).Encode(vulnerabilities)
}
```

## Testing

### Manual Testing

1. Import vulnerability data from a data source
2. Process software vulnerabilities
3. Identify host vulnerabilities
4. Verify vulnerabilities are displayed in the UI

### Automated Testing

Fleet includes automated tests for Vulnerability Management functionality:

```bash
# Run Vulnerability Management tests
go test -v ./server/service/vulnerability_management_test.go
```

## Debugging

### Vulnerability Data Source Issues

- **API Access**: Verify the vulnerability data source API is accessible
- **Data Format**: Ensure the data format matches the expected format
- **Error Handling**: Check if errors during data retrieval are properly handled

### Vulnerability Processing Issues

- **Database Schema**: Verify the database schema is correctly defined
- **Data Insertion**: Ensure vulnerability data is correctly inserted into the database
- **Transaction Management**: Check if database transactions are properly managed

## Performance Considerations

Vulnerability Management can involve processing large amounts of data:

- **Incremental Updates**: Implement incremental updates to reduce processing time
- **Background Processing**: Process vulnerabilities in the background
- **Caching**: Cache vulnerability data to improve performance
- **Indexing**: Ensure the database is properly indexed for efficient queries

## Related Resources

- [Vulnerability Management Architecture](../../architecture/software/vulnerability-management.md)
- [Vulnerability Processing](../vulnerability-processing.md)
- [National Vulnerability Database (NVD)](https://nvd.nist.gov/)
- [Common Vulnerability Scoring System (CVSS)](https://www.first.org/cvss/)