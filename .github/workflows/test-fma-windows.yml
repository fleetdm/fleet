name: Test Fleet Maintained Apps - Windows

on:
  # Note: PR triggers removed - use test-fma-windows-pr-only.yml for PRs
  # This workflow is kept for manual testing of all FMAs via workflow_dispatch
  workflow_dispatch: # Manual trigger
    inputs:
      log_level:
        description: "Log level (debug, info, warn, error)"
        required: false
        default: "info"
        type: choice
        options:
          - debug
          - info
          - warn
          - error

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

permissions:
  contents: read

jobs:
  test-fma:
    env:
      LOG_LEVEL: ${{ github.event.inputs.log_level || 'info' }}
    runs-on: windows-latest

    steps:
      - name: Checkout Fleet
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          repository: fleetdm/fleet
          fetch-depth: 1
          ref: ${{ github.ref }}
          path: fleet

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version-file: "fleet/go.mod"

      - name: Install osquery windows
        run: |
          Write-Host "Runner architecture: $env:PROCESSOR_ARCHITECTURE"
          curl -L -o osquery.zip "https://github.com/osquery/osquery/releases/download/5.18.1/osquery-5.18.1.windows_x86_64.zip"
          Expand-Archive -Path osquery.zip -DestinationPath osquery
          Get-ChildItem -Recurse osquery | Where-Object { $_.Name -like "*osquery*" -and $_.Extension -eq ".exe" }
          $osqueryPath = (Get-ChildItem -Recurse osquery | Where-Object { $_.Name -eq "osqueryi.exe" }).Directory.FullName
          echo "Adding to PATH: $osqueryPath"
          echo $osqueryPath | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        shell: pwsh

      - name: Remove pre-installed google chrome
        run: |
          Write-Host "Listing all installed packages containing 'Chrome':"
          Get-Package | Where-Object { $_.Name -like "*Chrome*" } | ForEach-Object {
            Write-Host "  - $($_.Name) (Version: $($_.Version))"
          }

          $uninstallPath = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | Where-Object { $_.DisplayName -like "*Google Chrome*" } | Select-Object -ExpandProperty UninstallString
          if ($uninstallPath) {
            Write-Host "Found Chrome uninstall path: $uninstallPath"
            try {
              $guid = ($uninstallPath -split "/X")[1]
              Write-Host "Uninstalling Chrome MSI with GUID: $guid"
              Start-Process -FilePath "msiexec.exe" -ArgumentList "/X$guid", "/quiet", "/norestart" -Wait -NoNewWindow
              Write-Host "Successfully removed Google Chrome via MSI uninstaller"
            } catch {
              Write-Host "Failed to remove Chrome: $($_.Exception.Message)"
            }
          } else {
            Write-Host "Chrome uninstall path not found in registry"
          }
        shell: pwsh

      - name: Install .NET Core Uninstall Tool
        run: |
          Write-Host "Downloading .NET Core Uninstall Tool..."
          $uninstallerUrl = "https://github.com/dotnet/cli-lab/releases/latest/download/dotnet-core-uninstall.msi"
          $uninstallerPath = "$env:TEMP\dotnet-core-uninstall.msi"
          Invoke-WebRequest -Uri $uninstallerUrl -OutFile $uninstallerPath
          
          Write-Host "Installing .NET Core Uninstall Tool..."
          Start-Process -FilePath "msiexec.exe" -ArgumentList "/i", "`"$uninstallerPath`"", "/quiet", "/norestart" -Wait -NoNewWindow
          
          # Add to PATH if not already there
          $uninstallerPath = "${env:ProgramFiles}\dotnet-core-uninstall"
          if (Test-Path $uninstallerPath) {
            Write-Host ".NET Core Uninstall Tool installed successfully"
          } else {
            Write-Host "Warning: .NET Core Uninstall Tool may not be in expected location"
          }
        shell: pwsh

      - name: Remove pre-installed .NET runtimes
        run: |
          Write-Host "Listing all installed .NET runtimes:"
          
          # Try to use dotnet-core-uninstall if available
          $uninstallerExe = "${env:ProgramFiles}\dotnet-core-uninstall\dotnet-core-uninstall.exe"
          if (Test-Path $uninstallerExe) {
            Write-Host "Using .NET Core Uninstall Tool..."
            & $uninstallerExe list --runtimes | Out-String | Write-Host
            
            # Get list of installed runtime versions
            $runtimeList = & $uninstallerExe list --runtimes 2>&1 | Out-String
            Write-Host $runtimeList
            
            # Remove all .NET Runtime versions (not just 6.0)
            # The tool supports removing all runtimes with --all flag or by version pattern
            Write-Host "Removing all installed .NET Runtime versions..."
            $removeOutput = & $uninstallerExe remove --runtime --all --yes 2>&1 | Out-String
            Write-Host $removeOutput
            
            # Verify removal
            $remainingRuntimes = & $uninstallerExe list --runtimes 2>&1 | Out-String
            if ($remainingRuntimes -match "Microsoft\.NET.*Runtime") {
              Write-Host "Warning: Some .NET Runtime installations may still be present"
              Write-Host $remainingRuntimes
            } else {
              Write-Host "Successfully removed all .NET Runtime installations"
            }
          } else {
            Write-Host ".NET Core Uninstall Tool not found, trying registry-based removal..."
            
            # Fallback: Try to find and remove via registry
            $uninstallPaths = @(
              "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*",
              "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*"
            )
            
            $foundRuntimes = @()
            foreach ($path in $uninstallPaths) {
              $entries = Get-ItemProperty $path -ErrorAction SilentlyContinue | Where-Object {
                $_.DisplayName -like "*Microsoft .NET Runtime*" -and
                $_.Publisher -eq "Microsoft Corporation"
              }
              if ($entries) {
                $foundRuntimes += $entries
              }
            }
            
            if ($foundRuntimes.Count -gt 0) {
              Write-Host "Found $($foundRuntimes.Count) .NET Runtime installation(s):"
              foreach ($runtime in $foundRuntimes) {
                Write-Host "  - $($runtime.DisplayName)"
                $uninstallString = if ($runtime.QuietUninstallString) {
                  $runtime.QuietUninstallString
                } elseif ($runtime.UninstallString) {
                  $runtime.UninstallString
                } else {
                  $null
                }
                
                if ($uninstallString) {
                  Write-Host "    Uninstall string: $uninstallString"
                  try {
                    # Parse uninstall string
                    if ($uninstallString -match '"([^"]+)"') {
                      $exePath = $matches[1]
                      $args = $uninstallString.Substring($matches[0].Length).Trim()
                      if (-not $args -or $args -notmatch "/silent") {
                        $args = "/silent"
                      }
                      Write-Host "    Executing: $exePath $args"
                      Start-Process -FilePath $exePath -ArgumentList $args -Wait -NoNewWindow
                      Write-Host "    Successfully removed $($runtime.DisplayName)"
                    } else {
                      Write-Host "    Could not parse uninstall string"
                    }
                  } catch {
                    Write-Host "    Failed to remove $($runtime.DisplayName): $($_.Exception.Message)"
                  }
                }
              }
            } else {
              Write-Host "No .NET Runtime installations found in registry"
            }
          }
        shell: pwsh

      - name: Verify Fleet Maintained Apps windows
        run: |
          ls "C:\Program Files"
          cd fleet
          go run ./cmd/maintained-apps/validate
        shell: pwsh
