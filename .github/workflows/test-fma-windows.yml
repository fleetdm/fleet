name: Test Fleet Maintained Apps - Windows

on:
  # Note: PR triggers removed - use test-fma-windows-pr-only.yml for PRs
  # This workflow is kept for manual testing of all FMAs via workflow_dispatch
  workflow_dispatch: # Manual trigger
    inputs:
      log_level:
        description: "Log level (debug, info, warn, error)"
        required: false
        default: "info"
        type: choice
        options:
          - debug
          - info
          - warn
          - error

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

permissions:
  contents: read

jobs:
  test-fma:
    env:
      LOG_LEVEL: ${{ github.event.inputs.log_level || 'info' }}
    runs-on: windows-latest

    steps:
      - name: Checkout Fleet
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          repository: fleetdm/fleet
          fetch-depth: 1
          ref: ${{ github.ref }}
          path: fleet

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version-file: "fleet/go.mod"

      - name: Install osquery windows
        run: |
          Write-Host "Runner architecture: $env:PROCESSOR_ARCHITECTURE"
          curl -L -o osquery.zip "https://github.com/osquery/osquery/releases/download/5.18.1/osquery-5.18.1.windows_x86_64.zip"
          Expand-Archive -Path osquery.zip -DestinationPath osquery
          Get-ChildItem -Recurse osquery | Where-Object { $_.Name -like "*osquery*" -and $_.Extension -eq ".exe" }
          $osqueryPath = (Get-ChildItem -Recurse osquery | Where-Object { $_.Name -eq "osqueryi.exe" }).Directory.FullName
          echo "Adding to PATH: $osqueryPath"
          echo $osqueryPath | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        shell: pwsh

      - name: Remove pre-installed google chrome
        run: |
          Write-Host "Listing all installed packages containing 'Chrome':"
          Get-Package | Where-Object { $_.Name -like "*Chrome*" } | ForEach-Object {
            Write-Host "  - $($_.Name) (Version: $($_.Version))"
          }

          $uninstallPath = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | Where-Object { $_.DisplayName -like "*Google Chrome*" } | Select-Object -ExpandProperty UninstallString
          if ($uninstallPath) {
            Write-Host "Found Chrome uninstall path: $uninstallPath"
            try {
              $guid = ($uninstallPath -split "/X")[1]
              Write-Host "Uninstalling Chrome MSI with GUID: $guid"
              Start-Process -FilePath "msiexec.exe" -ArgumentList "/X$guid", "/quiet", "/norestart" -Wait -NoNewWindow
              Write-Host "Successfully removed Google Chrome via MSI uninstaller"
            } catch {
              Write-Host "Failed to remove Chrome: $($_.Exception.Message)"
            }
          } else {
            Write-Host "Chrome uninstall path not found in registry"
          }
        shell: pwsh

      - name: Remove pre-installed .NET Runtime
        run: |
          Write-Host "Listing all installed .NET Runtime packages:"
          Get-Package | Where-Object { $_.Name -like "*Microsoft .NET Runtime*" } | ForEach-Object {
            Write-Host "  - $($_.Name) (Version: $($_.Version))"
          }

          # Check registry for all .NET Runtime uninstallers
          $uninstallPaths = @(
            "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*",
            "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*"
          )

          $displayName = "Microsoft .NET Runtime"
          $publisher = "Microsoft Corporation"
          $uninstallEntries = @()

          foreach ($path in $uninstallPaths) {
            $items = Get-ItemProperty $path -ErrorAction SilentlyContinue | Where-Object {
              $_.DisplayName -and ($_.DisplayName -like "*$displayName*") -and ($publisher -eq "" -or $_.Publisher -eq $publisher) -and $_.UninstallString
            }
            if ($items) {
              $uninstallEntries += $items
            }
          }

          if ($uninstallEntries.Count -eq 0) {
            Write-Host ".NET Runtime uninstall entries not found in registry"
          } else {
            Write-Host "Found $($uninstallEntries.Count) .NET Runtime installation(s) to uninstall"
            
            foreach ($uninstallEntry in $uninstallEntries) {
              Write-Host "Uninstalling: $($uninstallEntry.DisplayName)"
              
              $uninstallString = $uninstallEntry.UninstallString
              
              # Check if it's an MSI uninstall (contains /X{GUID} or /x{GUID})
              if ($uninstallString -match "/[Xx]\{([A-F0-9\-]+)\}") {
                $guid = $matches[1]
                Write-Host "  Found MSI GUID: $guid"
                try {
                  # Use /x (lowercase) and /qn (quiet no UI) - standard MSI uninstall flags
                  # Pass GUID directly without braces (msiexec handles it)
                  $process = Start-Process -FilePath "msiexec.exe" -ArgumentList @("/qn", "/x", $guid, "/norestart") -Wait -NoNewWindow -PassThru
                  Write-Host "  Exit code: $($process.ExitCode)"
                  
                  # MSI uninstalls can take time - wait longer
                  Start-Sleep -Seconds 5
                } catch {
                  Write-Host "  Error running msiexec: $_"
                }
              } else {
                # Try EXE-based uninstall
                $exePath = ""
                $arguments = ""

                # Parse the uninstall string to extract executable path and existing arguments
                if ($uninstallString -match '^"([^"]+)"(.*)') {
                    $exePath = $matches[1]
                    $arguments = $matches[2].Trim()
                } elseif ($uninstallString -match '^([^\s]+)(.*)') {
                    $exePath = $matches[1]
                    $arguments = $matches[2].Trim()
                } else {
                    Write-Host "  Error: Could not parse uninstall string: $uninstallString"
                    continue
                }

                # Build argument list array, preserving existing arguments and adding /quiet /norestart
                $argumentList = @()
                if ($arguments -ne '') {
                    $argumentList += $arguments -split '\s+'
                }
                if ($argumentList -notcontains "/quiet") {
                    $argumentList += "/quiet"
                }
                if ($argumentList -notcontains "/norestart") {
                    $argumentList += "/norestart"
                }

                Write-Host "  Executable: $exePath"
                Write-Host "  Arguments: $($argumentList -join ' ')"

                try {
                    $process = Start-Process -FilePath $exePath -ArgumentList $argumentList -Wait -NoNewWindow -PassThru
                    Write-Host "  Exit code: $($process.ExitCode)"
                } catch {
                    Write-Host "  Error running uninstaller: $_"
                }
              }
              
              # Wait a bit between uninstalls
              Start-Sleep -Seconds 2
            }

            # Wait for registry to update (MSI uninstalls can take longer)
            # Poll the registry until entries are gone or timeout
            $maxWaitTime = 120  # 2 minutes max
            $elapsed = 0
            $pollInterval = 5   # Check every 5 seconds
            $allRemoved = $false

            while ($elapsed -lt $maxWaitTime) {
              Start-Sleep -Seconds $pollInterval
              $elapsed += $pollInterval

              $remaining = @()
              foreach ($path in $uninstallPaths) {
                $items = Get-ItemProperty $path -ErrorAction SilentlyContinue | Where-Object {
                  $_.DisplayName -and ($_.DisplayName -like "*$displayName*") -and ($publisher -eq "" -or $_.Publisher -eq $publisher)
                }
                if ($items) {
                  $remaining += $items
                }
              }

              if ($remaining.Count -eq 0) {
                Write-Host "All .NET Runtime installations successfully uninstalled (waited $elapsed seconds)"
                $allRemoved = $true
                break
              } else {
                Write-Host "Still waiting for $($remaining.Count) installation(s) to be removed... (elapsed: $elapsed seconds)"
              }
            }

            if (-not $allRemoved) {
              Write-Host "Warning: $($remaining.Count) .NET Runtime installation(s) still remain after $maxWaitTime seconds"
              foreach ($item in $remaining) {
                Write-Host "  - $($item.DisplayName)"
              }
            }
          }
        shell: pwsh

      - name: Verify Fleet Maintained Apps windows
        run: |
          ls "C:\Program Files"
          cd fleet
          go run ./cmd/maintained-apps/validate
        shell: pwsh
